<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TowniVerse Isometric Builder</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --bg: #0f141a;
        --panel: rgba(15, 20, 26, 0.9);
        --accent: #ffe29a;
        --grid: rgba(255, 255, 255, 0.25);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #1c2733, #090c10 60%);
        color: #f2f6fb;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 1.5rem 2rem 0.5rem;
      }

      h1 {
        font-size: 1.75rem;
        margin: 0 0 0.25rem;
        letter-spacing: 0.05em;
      }

      p.subtitle {
        margin: 0;
        color: rgba(242, 246, 251, 0.7);
      }

      main {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(0, 4fr) minmax(240px, 1fr);
        gap: 1.25rem;
        padding: 0 2rem 1.5rem;
        min-height: calc(100vh - 140px);
        align-items: stretch;
      }

      #game-wrapper {
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 25px 65px rgba(0, 0, 0, 0.45);
        height: 100%;
        min-height: 100%;
      }

      canvas {
        display: block;
      }

      aside {
        background: var(--panel);
        border-radius: 20px;
        padding: 1.5rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        min-height: 0;
      }

      .panel-title {
        font-weight: 600;
        letter-spacing: 0.06em;
        margin-bottom: 0.3rem;
      }

      #tile-palette {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 0.75rem;
      }

      .tile-swatch {
        position: relative;
        width: 100%;
        padding-top: 70%;
        background: transparent;
        border: 1px dashed rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        cursor: pointer;
        transition: transform 120ms ease, border-color 120ms ease;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.02);
      }

      .tile-swatch .tile-remove {
        position: absolute;
        top: 0.35rem;
        right: 0.35rem;
        width: 1.4rem;
        height: 1.4rem;
        border: none;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        cursor: pointer;
        font-weight: 700;
      }

      .tile-swatch:focus-visible {
        outline: 2px solid var(--accent);
      }

      .tile-swatch.active {
        border-style: solid;
        border-color: var(--accent);
        transform: translateY(-3px);
      }

      .tile-swatch .diamond {
        position: absolute;
        inset: 15%;
        clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);
        border: 2px solid rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(2px);
      }

      .tile-swatch img {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 90%;
        height: 90%;
        transform: translate(-50%, -50%);
        object-fit: contain;
        pointer-events: none;
      }

      .tile-swatch .diamond.lot {
        background: linear-gradient(135deg, #d1e2c3, #a2c28a);
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.35);
      }

      .tile-swatch .diamond .building {
        position: absolute;
        width: 55%;
        height: 70%;
        left: 50%;
        bottom: 8%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #f9d4b3, #f6b68a);
        border-radius: 6px 6px 12px 12px;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35);
      }

      .tile-swatch .diamond .building::before {
        content: "";
        position: absolute;
        inset: -18% 4% 60%;
        background: linear-gradient(135deg, #fc9d6c, #e0703a);
        clip-path: polygon(50% 0, 100% 60%, 50% 90%, 0 60%);
      }

      .instructions {
        font-size: 0.95rem;
        line-height: 1.5;
        color: rgba(255, 255, 255, 0.8);
      }

      .instructions kbd {
        display: inline-block;
        padding: 0.15rem 0.4rem;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.45);
        font-size: 0.85rem;
        margin: 0 0.1rem;
      }

      .upload-panel {
        background: rgba(255, 255, 255, 0.04);
        border-radius: 16px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .upload-panel label {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.85);
      }

      .upload-panel input {
        padding: 0.4rem 0.6rem;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(0, 0, 0, 0.25);
        color: #fff;
      }

      .upload-panel button {
        padding: 0.45rem 0.75rem;
        border-radius: 10px;
        border: none;
        background: linear-gradient(120deg, #ffa75e, #ff6d6d);
        color: #0f141a;
        font-weight: 600;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }

      .upload-panel button:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 18px rgba(255, 113, 99, 0.4);
      }

      .tile-swatch .tile-remove {
        position: absolute;
        top: 0.35rem;
        right: 0.35rem;
        width: 1.4rem;
        height: 1.4rem;
        border: none;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        cursor: pointer;
        font-weight: 700;
      }

      #calibration-modal {
        position: fixed;
        inset: 0;
        background: rgba(5, 8, 12, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        opacity: 0;
        pointer-events: none;
        transition: opacity 180ms ease;
      }

      #calibration-modal.visible {
        opacity: 1;
        pointer-events: auto;
      }

      .calibration-card {
        background: #10161f;
        border-radius: 18px;
        padding: 1.25rem;
        width: min(640px, 90vw);
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 35px 50px rgba(0, 0, 0, 0.5);
      }

      .calibration-card h3 {
        margin: 0;
      }

      #calibration-canvas {
        width: 100%;
        height: auto;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        background: #0c1118;
        cursor: crosshair;
      }

      .calibration-actions {
        display: flex;
        gap: 0.5rem;
        justify-content: flex-end;
      }

      .calibration-actions button {
        padding: 0.45rem 0.8rem;
        border-radius: 10px;
        border: none;
        cursor: pointer;
      }

      #calibration-confirm {
        background: linear-gradient(120deg, #7cffc4, #5dcfff);
        color: #0c1118;
        font-weight: 600;
      }

      #calibration-reset,
      #calibration-skip {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      #drop-zone {
        border: 2px dashed rgba(255, 255, 255, 0.4);
        border-radius: 14px;
        padding: 1rem;
        text-align: center;
        color: rgba(255, 255, 255, 0.85);
        transition: border-color 150ms ease, color 150ms ease;
        cursor: pointer;
      }

      #drop-zone.dragover {
        border-color: var(--accent);
        color: var(--accent);
      }

      #upload-status {
        min-height: 1.3rem;
        font-size: 0.85rem;
        color: var(--accent);
      }

      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }

        aside {
          order: -1;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>TowniVerse Isometric Builder</h1>
      <p class="subtitle">
        투명 배경의 isometric 타일을 선택해서 와이어 격자 위에 마을을 쌓아 올려보세요.
      </p>
    </header>
    <main>
      <section id="game-wrapper"></section>
      <aside>
        <div>
          <div class="panel-title">타일 샘플</div>
          <div id="tile-palette"></div>
        </div>
        <div class="upload-panel">
          <div class="panel-title">새 PNG 업로드</div>
          <label>
            라벨
            <input id="upload-label" type="text" placeholder="예: 새 주택" />
          </label>
          <input id="file-input" type="file" accept="image/png" hidden />
          <div id="drop-zone">PNG 파일을 드래그하거나 클릭해 업로드</div>
          <div id="upload-status"></div>
          <button type="button" id="export-btn">ZIP으로 내보내기</button>
          <small>※ 업로드한 타일은 브라우저에만 저장됩니다. originY는 자동 계산됩니다.</small>
        </div>
      </aside>
    </main>

    <div id="calibration-modal">
      <div class="calibration-card">
        <h3>마름모 기준 맞추기</h3>
        <p id="calibration-hint">상단 꼭짓점을 클릭하세요.</p>
        <canvas id="calibration-canvas" width="520" height="360"></canvas>
        <div class="calibration-actions">
          <button type="button" id="calibration-reset">다시 찍기</button>
          <button type="button" id="calibration-skip">건너뛰기</button>
          <button type="button" id="calibration-confirm" disabled>확인</button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
      const TILE_WIDTH = 256;
      const TILE_HEIGHT = 128;
      const GRID_BUFFER = 3;
      const WORLD_BOUNDS = 200000;
      const WHEEL_SCROLL_FACTOR = 0.15;
      const gridOrigin = { x: 0, y: 0 };

      let builtInTiles = [];
      const fallbackTiles = [
        { key: "tile-grass", label: "잔디", originY: 0.5, url: "tiles/tile-grass.svg", textureScale: 1 },
        { key: "tile-sand", label: "모래", originY: 0.5, url: "tiles/tile-sand.svg", textureScale: 1.5 },
        { key: "tile-water", label: "물", originY: 0.5, url: "tiles/tile-water.svg", textureScale: 1 },
        { key: "tile-soil", label: "토양", originY: 0.5, url: "tiles/tile-soil.svg", textureScale: 1 },
        { key: "tile-snow", label: "설원", originY: 0.5, url: "tiles/tile-snow.svg", textureScale: 2 },
      ].map((tile) => ({ ...tile, isCustom: false }));

      const tileStore = createTileStore();
      const calibrator = createCalibrator();
      const uploadElements = {
        dropZone: document.getElementById("drop-zone"),
        fileInput: document.getElementById("file-input"),
        labelInput: document.getElementById("upload-label"),
        status: document.getElementById("upload-status"),
      };
      const exportButton = document.getElementById("export-btn");

      const paletteContainer = document.getElementById("tile-palette");
      paletteContainer.textContent = "타일을 불러오는 중...";

      let palette = [];
      let tileDefinitions = new Map();
      let activeTileKey = null;
      const placedTiles = new Map();
      const spriteCache = new Map();
      const runtimeUrls = new Map();
      let game = null;

      paletteContainer.addEventListener("click", (event) => {
        const button = event.target.closest(".tile-swatch");
        if (!button) return;
        setActiveTile(button.dataset.tileKey);
      });

      init();

      async function init() {
        setupUploader();
        setupExportButton();
        builtInTiles = await loadManifestTiles();
        await loadPaletteAndStart();

        // 저장된 배치 로드
        await loadSavedPlacements();
      }

      async function loadSavedPlacements() {
        try {
          const placements = await tileStore.getPlacements();
          placements.forEach(({ key, tileKey, col, row }) => {
            placedTiles.set(key, { tileKey, grid: { col, row } });
          });
          console.log(`Loaded ${placements.length} placements from storage`);

          // 게임이 이미 시작되었으면 화면 갱신
          if (game) {
            const activeScene = game.scene.getAt(0);
            if (activeScene) {
              refreshSceneView(activeScene);
            }
          }
        } catch (error) {
          console.error("Failed to load placements:", error);
        }
      }

      async function loadManifestTiles() {
        try {
          const response = await fetch("tiles/manifest.json", { cache: "no-store" });
          if (!response.ok) throw new Error("manifest load failed");
          const manifest = await response.json();
          if (!Array.isArray(manifest.tiles)) throw new Error("no tiles array");
          return manifest.tiles.map((tile) => ({
            key: tile.key,
            label: tile.label || tile.key,
            originY: tile.originY ?? 0.5,
            textureScale: tile.scale ?? 1,
            displayScale: tile.displayScale,
            url: tile.file || tile.url,
            isCustom: false,
          }));
        } catch (error) {
          console.warn("manifest 로드 실패, 기본 타일 사용", error);
          return fallbackTiles;
        }
      }

      async function loadPaletteAndStart() {
        const customTiles = await tileStore.getTiles();
        runtimeUrls.forEach((url) => URL.revokeObjectURL(url));
        runtimeUrls.clear();
        palette = [...builtInTiles, ...customTiles];
        if (!palette.length) {
          paletteContainer.textContent = "등록된 타일이 없습니다.";
          return;
        }

        palette.forEach((tile) => {
          if (tile.isCustom) {
            tile.previewUrl = tile.dataUrl;
            const blob = dataURLToBlob(tile.dataUrl);
            const runtime = URL.createObjectURL(blob);
            runtimeUrls.set(tile.key, runtime);
            tile.runtimeUrl = runtime;
            tile.isSvg = false;
          } else {
            const url = tile.url || tile.file;
            tile.previewUrl = url;
            tile.runtimeUrl = url;
            tile.isSvg = url?.toLowerCase().endsWith(".svg");
          }
        });

        tileDefinitions = new Map(palette.map((tile) => [tile.key, tile]));
        if (!activeTileKey || !tileDefinitions.has(activeTileKey)) {
          activeTileKey = palette[0].key;
        }

        renderPalette();
        if (!game) {
          startGame();
        } else {
          await registerMissingTextures();
        }
      }

      function renderPalette() {
        paletteContainer.innerHTML = "";
        palette.forEach((tile) => {
          const button = document.createElement("button");
          button.className = "tile-swatch" + (tile.key === activeTileKey ? " active" : "");
          button.type = "button";
          button.dataset.tileKey = tile.key;

          const preview = document.createElement("img");
          preview.src = tile.previewUrl;
          preview.alt = tile.label;
          preview.loading = "lazy";
          preview.decoding = "async";
          preview.draggable = false;

          button.appendChild(preview);
          if (tile.isCustom) {
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.className = "tile-remove";
            removeBtn.textContent = "×";
            removeBtn.title = "타일 삭제";
            removeBtn.addEventListener("click", async (event) => {
              event.stopPropagation();
              await tileStore.deleteTile(tile.key);
              if (activeTileKey === tile.key) {
                activeTileKey = builtInTiles[0]?.key || null;
              }
              await loadPaletteAndStart();
            });
            button.appendChild(removeBtn);
          }
          paletteContainer.appendChild(button);
        });
      }

      function setActiveTile(tileKey) {
        if (!tileDefinitions.has(tileKey)) return;
        activeTileKey = tileKey;
        document
          .querySelectorAll(".tile-swatch")
          .forEach((el) => el.classList.toggle("active", el.dataset.tileKey === tileKey));
      }

      function startGame() {
        if (game) {
          return;
        }

        const scene = {
          preload: preloadScene,
          create: createScene,
          update: updateScene,
        };

        const config = {
          type: Phaser.AUTO,
          parent: "game-wrapper",
          width: 1600,
          height: 900,
          backgroundColor: "rgba(0,0,0,0)",
          transparent: true,
          scene,
          pixelArt: true,
          scale: {
            parent: "game-wrapper",
            mode: Phaser.Scale.RESIZE,
            autoCenter: Phaser.Scale.CENTER_BOTH,
          },
        };
        game = new Phaser.Game(config);
      }

      function preloadScene() {
        palette.forEach((tile) => {
          const textureScale = tile.textureScale ?? tile.scale ?? 1;
          const assetUrl = tile.runtimeUrl;
          if (tile.isSvg && this.load.svg) {
            this.load.svg(tile.key, assetUrl, { scale: textureScale });
          } else {
            this.load.image(tile.key, assetUrl);
          }
        });
      }

      function createScene() {
        this.cameras.main.setBounds(
          -WORLD_BOUNDS,
          -WORLD_BOUNDS,
          WORLD_BOUNDS * 2,
          WORLD_BOUNDS * 2
        );
        this.cameras.main.setZoom(1);
        this.cameras.main.setBackgroundColor("rgba(0,0,0,0)");
        this.cameras.main.centerOn(0, 0);

        this.gridGraphics = this.add.graphics();
        this.gridGraphics.setDepth(-1000);

        palette.forEach((tile) => {
          if (this.textures.exists(tile.key)) {
            tile.loaded = true;
          }
        });

        this.scale.on("resize", () => {
          refreshSceneView(this);
          updateDepths(this.cameras.main);
        });

        this.cursors = this.input.keyboard.createCursorKeys();
        this.input.on("wheel", (pointer, gameObjects, deltaX, deltaY, deltaZ, event) => {
          const cam = this.cameras.main;
          cam.scrollX += deltaX * WHEEL_SCROLL_FACTOR;
          cam.scrollY += deltaY * WHEEL_SCROLL_FACTOR;
          refreshSceneView(this);
          updateDepths(cam);
          event?.preventDefault();
        });
        this.input.on("pointerdown", async (pointer) => {
          if (!activeTileKey) return;
          const worldPoint = pointer.positionToCamera(this.cameras.main);
          const gridPoint = screenToGrid(worldPoint.x, worldPoint.y);

          if (!gridPoint) return;
          const key = `${gridPoint.col}-${gridPoint.row}`;
          const existing = placedTiles.get(key);
          if (existing && existing.tileKey === activeTileKey) {
            placedTiles.delete(key);
            const sprite = spriteCache.get(key);
            if (sprite) {
              sprite.destroy();
              spriteCache.delete(key);
            }
            // DB에서도 삭제
            await tileStore.deletePlacement(key);
            refreshSceneView(this);
            return;
          }

          placedTiles.set(key, { tileKey: activeTileKey, grid: gridPoint });
          const sprite = spriteCache.get(key);
          if (sprite) {
            sprite.destroy();
            spriteCache.delete(key);
          }
          // DB에 저장
          await tileStore.savePlacement(key, activeTileKey, gridPoint.col, gridPoint.row);
          refreshSceneView(this);
        });

        refreshSceneView(this);
      }

      function updateScene(_, delta) {
        if (!this.cursors) return;
        const cam = this.cameras.main;
        const speed = 0.25 * delta;
        let moved = false;

        if (this.cursors.left.isDown) {
          cam.scrollX -= speed;
          moved = true;
        } else if (this.cursors.right.isDown) {
          cam.scrollX += speed;
          moved = true;
        }

        if (this.cursors.up.isDown) {
          cam.scrollY -= speed;
          moved = true;
        } else if (this.cursors.down.isDown) {
          cam.scrollY += speed;
          moved = true;
        }

        if (moved) {
          refreshSceneView(this);
          updateDepths(cam);
        }
      }

      function refreshSceneView(scene) {
        const bounds = getVisibleBounds(scene.cameras.main, GRID_BUFFER);
        drawWireGrid(scene, bounds);
        syncVisibleTiles(scene, bounds);
      }

      function updateDepths(camera) {
        const offset = camera.scrollY;
        spriteCache.forEach((sprite) => {
          sprite.setDepth(sprite.y - offset);
        });
      }

      function syncVisibleTiles(scene, bounds) {
        spriteCache.forEach((sprite, key) => {
          const data = placedTiles.get(key);
          if (!data || !isWithinBounds(data.grid, bounds)) {
            sprite.destroy();
            spriteCache.delete(key);
          }
        });

        placedTiles.forEach((data, key) => {
          if (!isWithinBounds(data.grid, bounds)) return;

          if (!tileDefinitions.get(data.tileKey)?.loaded) {
            return;
          }

          let sprite = spriteCache.get(key);
          if (!sprite) {
            const tileDef = tileDefinitions.get(data.tileKey);
            if (!tileDef) return;
            const world = gridToScreen(data.grid.col, data.grid.row);
            sprite = scene.add.image(world.x, world.y, data.tileKey);
            sprite.setOrigin(0.5, tileDef.originY ?? 0.5);
            const targetWidth = tileDef.fitWidth ?? TILE_WIDTH;
            const autoScale = sprite.width ? targetWidth / sprite.width : 1;
            const scale = tileDef.displayScale ?? autoScale;
            if (scale && Math.abs(scale - 1) > 0.001) {
              sprite.setScale(scale);
            }
            spriteCache.set(key, sprite);
          }
          sprite.setDepth(sprite.y - scene.cameras.main.scrollY);
        });
      }

      function drawWireGrid(scene, bounds) {
        if (!scene.gridGraphics) return;
        scene.gridGraphics.clear();
        scene.gridGraphics.lineStyle(1.5, 0xffffff, 0.22);

        for (let row = bounds.minRow; row <= bounds.maxRow; row++) {
          for (let col = bounds.minCol; col <= bounds.maxCol; col++) {
            const center = gridToScreen(col, row);
            const diamond = diamondPoints(center.x, center.y);
            scene.gridGraphics.strokePoints(diamond, true);
          }
        }
      }

      function diamondPoints(x, y) {
        return diamondPointsScaled(x, y);
      }

      function diamondPointsScaled(x, y, width = TILE_WIDTH, height = TILE_HEIGHT) {
        return [
          new Phaser.Math.Vector2(x, y - height / 2),
          new Phaser.Math.Vector2(x + width / 2, y),
          new Phaser.Math.Vector2(x, y + height / 2),
          new Phaser.Math.Vector2(x - width / 2, y),
        ];
      }

      function gridToScreen(col, row) {
        return {
          x: gridOrigin.x + (col - row) * (TILE_WIDTH / 2),
          y: gridOrigin.y + (col + row) * (TILE_HEIGHT / 2),
        };
      }

      function screenToGrid(x, y) {
        const grid = screenToGridFloat(x, y);
        const col = Math.round(grid.col);
        const row = Math.round(grid.row);

        const world = gridToScreen(col, row);
        const diamond = diamondPoints(world.x, world.y);
        const polygon = new Phaser.Geom.Polygon(diamond);
        if (!Phaser.Geom.Polygon.Contains(polygon, x, y)) {
          return null;
        }
        return { col, row };
      }

      function screenToGridFloat(x, y) {
        const cx = x - gridOrigin.x;
        const cy = y - gridOrigin.y;
        const col = (cx / (TILE_WIDTH / 2) + cy / (TILE_HEIGHT / 2)) / 2;
        const row = (cy / (TILE_HEIGHT / 2) - cx / (TILE_WIDTH / 2)) / 2;
        return { col, row };
      }

      function getVisibleBounds(camera, padding = 0) {
        const view = camera.worldView;
        const corners = [
          { x: view.left, y: view.top },
          { x: view.right, y: view.top },
          { x: view.right, y: view.bottom },
          { x: view.left, y: view.bottom },
        ];
        const cols = [];
        const rows = [];
        corners.forEach((corner) => {
          const grid = screenToGridFloat(corner.x, corner.y);
          cols.push(grid.col);
          rows.push(grid.row);
        });

        const minCol = Math.floor(Math.min(...cols)) - padding;
        const maxCol = Math.ceil(Math.max(...cols)) + padding;
        const minRow = Math.floor(Math.min(...rows)) - padding;
        const maxRow = Math.ceil(Math.max(...rows)) + padding;
        return { minCol, maxCol, minRow, maxRow };
      }

      function isWithinBounds(grid, bounds) {
        return (
          grid.col >= bounds.minCol &&
          grid.col <= bounds.maxCol &&
          grid.row >= bounds.minRow &&
          grid.row <= bounds.maxRow
        );
      }

      function setupUploader() {
        const {
          dropZone,
          fileInput,
          labelInput,
          status,
        } = uploadElements;
        if (!dropZone || !fileInput) return;

        const stop = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        ["dragenter", "dragover"].forEach((evt) => {
          dropZone?.addEventListener(evt, (event) => {
            stop(event);
            dropZone.classList.add("dragover");
          });
        });

        ["dragleave", "drop"].forEach((evt) => {
          dropZone?.addEventListener(evt, (event) => {
            stop(event);
            dropZone.classList.remove("dragover");
          });
        });

        dropZone.addEventListener("drop", (event) => {
          const file = event.dataTransfer?.files?.[0];
          if (file) {
            handleUpload(file);
          }
        });

        dropZone.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", () => {
          const file = fileInput.files?.[0];
          if (file) {
            handleUpload(file);
            fileInput.value = "";
          }
        });

        async function handleUpload(file) {
          if (!file.type.includes("png")) {
            status.textContent = "PNG 파일만 업로드 가능합니다.";
            return;
          }
          const label = (labelInput?.value || file.name.replace(/\.png$/i, "")).trim();
          status.textContent = "이미지 준비...";

          try {
            // 원본 이미지를 적당한 크기로 리사이즈 (calibration용)
            const basePreview = await resizePngBlob(file, TILE_WIDTH * 2);
            status.textContent = "보정 준비...";
            const calibration = await calibrator.open(basePreview);

            // calibration이 완료되면 이미 정확한 크기로 변환되어 있음
            const finalBlob = calibration?.blob || basePreview;
            const dataUrl = await blobToDataURL(finalBlob);

            // 이미지 크기를 확인하여 originY 계산
            const img = await loadImageElement(dataUrl);
            // 마름모 중심이 격자 중심에 와야 함
            // 마름모 하단이 이미지 하단에 있고, 마름모 높이는 TILE_HEIGHT/2
            // originY = (이미지 하단 - TILE_HEIGHT/2) / 이미지 높이
            const diamondCenterFromBottom = TILE_HEIGHT / 2;
            const calculatedOriginY = (img.height - diamondCenterFromBottom) / img.height;

            const savedTile = await tileStore.addTile({
              label,
              originY: calculatedOriginY,
              dataUrl,
              displayScale: 1,  // 이미 정확한 크기로 변환됨
            });
            status.textContent = "업로드 완료! 팔레트를 갱신합니다.";
            await loadPaletteAndStart();

            status.textContent = "텍스처 로딩 중...";
            await registerMissingTextures();

            // 새로 추가된 타일을 자동으로 선택
            setActiveTile(savedTile.key);

            // 디버깅: 타일 로드 상태 확인
            const newTile = tileDefinitions.get(savedTile.key);
            console.log("New tile loaded status:", newTile?.loaded, "key:", savedTile.key);

            status.textContent = "새 타일이 추가되었습니다. 클릭하여 배치하세요!";
          } catch (error) {
            status.textContent = "업로드 실패: " + error;
          }
        }
      }

      function setupExportButton() {
        if (!exportButton) return;
        exportButton.addEventListener("click", async () => {
          exportButton.disabled = true;
          const originalText = exportButton.textContent;
          exportButton.textContent = "내보내는 중...";
          try {
            await exportProject();
          } catch (error) {
            alert("내보내기 실패: " + error);
          } finally {
            exportButton.disabled = false;
            exportButton.textContent = originalText;
          }
        });
      }

      async function exportProject() {
        if (!window.JSZip) throw new Error("JSZip을 불러오지 못했습니다.");
        const zip = new JSZip();
        const manifest = {
          tiles: palette.map((tile) => ({
            key: tile.key,
            label: tile.label,
            originY: tile.originY,
            scale: tile.textureScale ?? tile.scale ?? 1,
            displayScale: tile.displayScale,
            file: `tiles/${tile.key}${tile.isSvg ? ".svg" : ".png"}`,
          })),
          placements: Array.from(placedTiles.values()).map((entry) => ({
            tileKey: entry.tileKey,
            col: entry.grid.col,
            row: entry.grid.row,
          })),
        };

        zip.file("manifest.json", JSON.stringify(manifest, null, 2));

        for (const tile of palette) {
          const ext = tile.isSvg ? ".svg" : ".png";
          const filename = `tiles/${tile.key}${ext}`;
          const blob = await getTileBlob(tile);
          zip.file(filename, blob);
        }

        const blob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `TowniVerse-${Date.now()}.zip`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }

      async function getTileBlob(tile) {
        if (tile.isCustom && tile.dataUrl) {
          return dataURLToBlob(tile.dataUrl);
        }
        const response = await fetch(tile.runtimeUrl || tile.url);
        if (!response.ok) throw new Error(`파일을 읽을 수 없습니다: ${tile.url}`);
        return await response.blob();
      }

      async function resizePngBlob(file, targetWidth) {
        const bitmap = await createImageBitmap(file);
        const ratio = targetWidth / bitmap.width;
        const targetHeight = Math.max(1, Math.round(bitmap.height * ratio));
        const canvas = document.createElement("canvas");
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(bitmap, 0, 0, targetWidth, targetHeight);
        bitmap.close();
        return await new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (blob) resolve(blob);
            else reject(new Error("리사이즈 실패"));
          }, "image/png");
        });
      }

      function blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

      function dataURLToBlob(dataUrl) {
        const [meta, content] = dataUrl.split(",");
        const mime = meta.match(/:(.*?);/)?.[1] || "image/png";
        const binary = atob(content);
        const array = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          array[i] = binary.charCodeAt(i);
        }
        return new Blob([array], { type: mime });
      }

      async function registerMissingTextures() {
        if (!game) return;
        const promises = [];
        palette.forEach((tile) => {
          if (game.textures.exists(tile.key)) {
            tile.loaded = true;
            console.log("Texture already exists:", tile.key);
            return;
          }
          if (tile.isCustom && tile.dataUrl) {
            console.log("Loading custom texture:", tile.key);
            promises.push(
              new Promise((resolve, reject) => {
                try {
                  game.textures.once('addtexture', (key) => {
                    if (key === tile.key) {
                      tile.loaded = true;
                      console.log("Custom texture loaded:", tile.key);
                      resolve();
                    }
                  });
                  game.textures.addBase64(tile.key, tile.dataUrl);
                  // Fallback: resolve after timeout
                  setTimeout(() => {
                    if (!tile.loaded) {
                      tile.loaded = game.textures.exists(tile.key);
                      console.log("Texture load timeout, forced check:", tile.key, tile.loaded);
                      resolve();
                    }
                  }, 1000);
                } catch (error) {
                  console.error("Error loading texture:", tile.key, error);
                  reject(error);
                }
              })
            );
          } else if (tile.runtimeUrl || tile.url) {
            const source = tile.runtimeUrl || tile.url;
            promises.push(
              fetchAsDataURL(source).then((dataUrl) => {
                return new Promise((resolve, reject) => {
                  try {
                    game.textures.once('addtexture', (key) => {
                      if (key === tile.key) {
                        tile.loaded = true;
                        resolve();
                      }
                    });
                    game.textures.addBase64(tile.key, dataUrl);
                    setTimeout(() => {
                      if (!tile.loaded) {
                        tile.loaded = game.textures.exists(tile.key);
                        resolve();
                      }
                    }, 1000);
                  } catch (error) {
                    console.error("Error loading texture:", tile.key, error);
                    reject(error);
                  }
                });
              })
            );
          }
        });
        await Promise.all(promises);
        console.log("All textures registered");
        const activeScene = game.scene.getAt(0);
        if (activeScene) {
          refreshSceneView(activeScene);
        }
      }

      async function fetchAsDataURL(url) {
        const response = await fetch(url);
        if (!response.ok) throw new Error("텍스처를 불러오지 못했습니다: " + url);
        const blob = await response.blob();
        return await blobToDataURL(blob);
      }

      function createCalibrator() {
        const modal = document.getElementById("calibration-modal");
        const canvas = document.getElementById("calibration-canvas");
        const hint = document.getElementById("calibration-hint");
        const confirmBtn = document.getElementById("calibration-confirm");
        const skipBtn = document.getElementById("calibration-skip");
        const resetBtn = document.getElementById("calibration-reset");
        const ctx = canvas.getContext("2d");
        const ORDER = ["상단", "오른쪽", "하단", "왼쪽"];

        let resolveFn = null;
        let image = null;
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let points = [];

        canvas.addEventListener("click", (event) => {
          if (!image || points.length >= 4) return;
          const rect = canvas.getBoundingClientRect();
          const ratioX = canvas.width / rect.width;
          const ratioY = canvas.height / rect.height;
          const canvasX = (event.clientX - rect.left) * ratioX;
          const canvasY = (event.clientY - rect.top) * ratioY;
          const imgX = (canvasX - offsetX) / scale;
          const imgY = (canvasY - offsetY) / scale;
          points.push({
            x: Math.max(0, Math.min(image.width, imgX)),
            y: Math.max(0, Math.min(image.height, imgY)),
            canvasX,
            canvasY,
          });
          drawOverlay();
          updateHint();
        });

        resetBtn.addEventListener("click", () => {
          points = [];
          drawOverlay();
          updateHint();
        });

        skipBtn.addEventListener("click", () => {
          close(null);
        });

        confirmBtn.addEventListener("click", async () => {
          if (!image || points.length < 4) return;
          try {
            const ordered = {
              top: points[0],
              right: points[1],
              bottom: points[2],
              left: points[3],
            };

            // 목표: 정확한 256x128 마름모로 변환하고 타일 크기에 맞추기
            // 출력 캔버스: 타일 크기의 2배로 설정 (변환 중 필요한 여유 공간)
            const outputWidth = TILE_WIDTH * 2;
            const outputHeight = TILE_HEIGHT * 4;  // 높이는 건물이 높을 수 있으니 여유있게

            // 마름모를 캔버스 하단 중앙에 배치
            const centerX = outputWidth / 2;
            const baseY = outputHeight - TILE_HEIGHT;  // 하단에서 한 타일 높이만큼 위

            // 목표: 정확한 256x128 마름모를 하단 중앙에 배치
            const dstTop = { x: centerX, y: baseY - TILE_HEIGHT / 2 };
            const dstRight = { x: centerX + TILE_WIDTH / 2, y: baseY };
            const dstBottom = { x: centerX, y: baseY + TILE_HEIGHT / 2 };
            const dstLeft = { x: centerX - TILE_WIDTH / 2, y: baseY };

            const warpedBlob = await warpImageWithPerspective(
              image,
              [ordered.top, ordered.right, ordered.bottom, ordered.left],
              [dstTop, dstRight, dstBottom, dstLeft],
              outputWidth,
              outputHeight
            );

            // 여백 제거 - 하지만 마름모 하단을 기준점으로 유지
            status.textContent = "여백 제거 중...";
            const trimmedBlob = await trimTransparentEdgesWithBase(warpedBlob, baseY + TILE_HEIGHT / 2);

            close({ blob: trimmedBlob });
          } catch (error) {
            console.error("calibration error", error);
            close(null);
          }
        });

        function updateHint() {
          if (!hint) return;
          if (points.length < 4) {
            hint.textContent = `${ORDER[points.length]} 꼭짓점을 클릭하세요.`;
            confirmBtn.disabled = true;
          } else {
            hint.textContent = "확인 버튼을 눌러 보정을 완료하세요.";
            confirmBtn.disabled = false;
          }
        }

        function drawOverlay() {
          if (!image) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
          }
          const scaleX = canvas.width / image.width;
          const scaleY = canvas.height / image.height;
          scale = Math.min(scaleX, scaleY);
          offsetX = (canvas.width - image.width * scale) / 2;
          offsetY = (canvas.height - image.height * scale) / 2;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();
          ctx.translate(offsetX, offsetY);
          ctx.scale(scale, scale);
          ctx.drawImage(image, 0, 0);
          ctx.restore();

          ctx.fillStyle = "#ffbd4a";
          ctx.strokeStyle = "#ffbd4a";
          ctx.lineWidth = 2;
          if (points.length) {
            ctx.beginPath();
            points.forEach((p, index) => {
              const x = p.canvasX;
              const y = p.canvasY;
              if (index === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            });
            ctx.stroke();
          }
          points.forEach((p) => {
            ctx.beginPath();
            ctx.arc(p.canvasX, p.canvasY, 5, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        function close(result) {
          modal.classList.remove("visible");
          image = null;
          points = [];
          confirmBtn.disabled = true;
          if (resolveFn) {
            resolveFn(result || null);
            resolveFn = null;
          }
        }

        function syncCanvasSize() {
          const rect = canvas.getBoundingClientRect();
          canvas.width = rect.width;
          canvas.height = rect.height;
        }

        return {
          async open(file) {
            const dataUrl = await blobToDataURL(file);
            image = await loadImageElement(dataUrl);
            points = [];
            syncCanvasSize();
            drawOverlay();
            updateHint();
            modal.classList.add("visible");
            return new Promise((resolve) => {
              resolveFn = resolve;
            });
          },
        };
      }

      function computePerspectiveTransform(srcPts, dstPts) {
        // 4점 perspective transform 계산 (homography)
        // 8개 방정식 (x,y 각 4쌍)으로 8개 미지수 해결
        const matrix = [];
        const vector = [];

        for (let i = 0; i < 4; i++) {
          const { x, y } = srcPts[i];
          const { x: X, y: Y } = dstPts[i];

          // X 방정식: X = (ax + by + c) / (gx + hy + 1)
          // -> ax + by + c - gxX - hyX - X = 0
          matrix.push([x, y, 1, 0, 0, 0, -x*X, -y*X]);
          vector.push(X);

          // Y 방정식: Y = (dx + ey + f) / (gx + hy + 1)
          // -> dx + ey + f - gxY - hyY - Y = 0
          matrix.push([0, 0, 0, x, y, 1, -x*Y, -y*Y]);
          vector.push(Y);
        }

        const solution = solveLinearSystem(matrix, vector);
        return {
          a: solution[0], b: solution[1], c: solution[2],
          d: solution[3], e: solution[4], f: solution[5],
          g: solution[6], h: solution[7]
        };
      }

      function solveLinearSystem(matrix, vector) {
        const size = matrix.length;
        const numVars = matrix[0].length;
        const M = matrix.map((row, i) => [...row, vector[i]]);

        // Gaussian elimination with partial pivoting
        for (let col = 0; col < numVars; col++) {
          let pivot = col;
          for (let row = col + 1; row < size; row++) {
            if (Math.abs(M[row][col]) > Math.abs(M[pivot][col])) {
              pivot = row;
            }
          }
          const temp = M[col];
          M[col] = M[pivot];
          M[pivot] = temp;
          const pivotVal = M[col][col] || 1e-10;
          for (let j = col; j <= numVars; j++) {
            M[col][j] /= pivotVal;
          }
          for (let row = 0; row < size; row++) {
            if (row === col) continue;
            const factor = M[row][col];
            for (let j = col; j <= numVars; j++) {
              M[row][j] -= factor * M[col][j];
            }
          }
        }
        return M.map((row) => row[numVars]);
      }

      async function warpImageWithPerspective(image, srcPts, dstPts, outputWidth, outputHeight) {
        // perspective transform 계산
        const H = computePerspectiveTransform(srcPts, dstPts);

        // 역변환 행렬 계산 (destination -> source mapping)
        const invH = computePerspectiveTransform(dstPts, srcPts);

        const canvas = document.createElement("canvas");
        canvas.width = outputWidth;
        canvas.height = outputHeight;
        const ctx = canvas.getContext("2d");

        // 임시 캔버스에 원본 이미지 그리기
        const srcCanvas = document.createElement("canvas");
        srcCanvas.width = image.width;
        srcCanvas.height = image.height;
        const srcCtx = srcCanvas.getContext("2d");
        srcCtx.drawImage(image, 0, 0);
        const srcData = srcCtx.getImageData(0, 0, image.width, image.height);
        const srcPixels = srcData.data;

        // 출력 이미지 데이터
        const dstData = ctx.createImageData(outputWidth, outputHeight);
        const dstPixels = dstData.data;

        // 역방향 매핑으로 각 픽셀 변환
        for (let dstY = 0; dstY < outputHeight; dstY++) {
          for (let dstX = 0; dstX < outputWidth; dstX++) {
            // destination 좌표를 source 좌표로 변환
            const src = applyPerspectiveTransform(invH, dstX, dstY);
            const srcX = Math.round(src.x);
            const srcY = Math.round(src.y);

            // 범위 체크
            if (srcX >= 0 && srcX < image.width && srcY >= 0 && srcY < image.height) {
              const srcIdx = (srcY * image.width + srcX) * 4;
              const dstIdx = (dstY * outputWidth + dstX) * 4;
              dstPixels[dstIdx] = srcPixels[srcIdx];         // R
              dstPixels[dstIdx + 1] = srcPixels[srcIdx + 1]; // G
              dstPixels[dstIdx + 2] = srcPixels[srcIdx + 2]; // B
              dstPixels[dstIdx + 3] = srcPixels[srcIdx + 3]; // A
            }
          }
        }

        ctx.putImageData(dstData, 0, 0);

        return await new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (blob) resolve(blob);
            else reject(new Error("perspective warp failed"));
          }, "image/png");
        });
      }

      function applyPerspectiveTransform(H, x, y) {
        const w = H.g * x + H.h * y + 1;
        return {
          x: (H.a * x + H.b * y + H.c) / w,
          y: (H.d * x + H.e * y + H.f) / w,
        };
      }

      function distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
      }

      async function trimTransparentEdgesWithBase(blob, baseY) {
        const img = await loadImageElement(await blobToDataURL(blob));
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        let minX = canvas.width;
        let minY = canvas.height;
        let maxX = 0;
        let maxY = 0;

        // 투명하지 않은 픽셀의 경계 찾기
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const alpha = pixels[(y * canvas.width + x) * 4 + 3];
            if (alpha > 0) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          }
        }

        // 여백이 없는 경우 원본 반환
        if (minX > maxX || minY > maxY) {
          return blob;
        }

        // 크롭: 좌우는 콘텐츠 기준, 상단은 콘텐츠 기준, 하단은 baseY 기준
        const cropX = minX;
        const cropY = minY;
        const cropWidth = maxX - minX + 1;
        const cropHeight = Math.ceil(baseY) - minY + 1;  // baseY까지 포함

        const croppedCanvas = document.createElement("canvas");
        croppedCanvas.width = cropWidth;
        croppedCanvas.height = cropHeight;
        const croppedCtx = croppedCanvas.getContext("2d");
        croppedCtx.drawImage(canvas, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

        return await new Promise((resolve, reject) => {
          croppedCanvas.toBlob((blob) => {
            if (blob) resolve(blob);
            else reject(new Error("trim failed"));
          }, "image/png");
        });
      }

      function loadImageElement(dataUrl) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = dataUrl;
        });
      }

      function createTileStore() {
        const DB_NAME = "TowniVerseLocal";
        const STORE = "tiles";
        const PLACEMENTS_STORE = "placements";
        const dbPromise = new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, 2);  // 버전 2로 업그레이드
          request.onupgradeneeded = (event) => {
            const db = request.result;
            if (!db.objectStoreNames.contains(STORE)) {
              db.createObjectStore(STORE, { keyPath: "id", autoIncrement: true });
            }
            if (!db.objectStoreNames.contains(PLACEMENTS_STORE)) {
              db.createObjectStore(PLACEMENTS_STORE, { keyPath: "key" });
            }
          };
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });

        async function tx(mode) {
          const db = await dbPromise;
          return db.transaction(STORE, mode).objectStore(STORE);
        }

        return {
          async getTiles() {
            const store = await tx("readonly");
            return await new Promise((resolve, reject) => {
              const request = store.getAll();
              request.onsuccess = () => {
                const tiles = request.result.map((entry) => ({
                  key: entry.key,
                  label: entry.label,
                  originY: entry.originY,
                  displayScale: entry.displayScale ?? 1,
                  dataUrl: entry.dataUrl,
                  isCustom: true,
                }));
                resolve(tiles);
              };
              request.onerror = () => reject(request.error);
            });
          },
          async addTile({ label, originY, dataUrl, displayScale = 1 }) {
            const key = `custom-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`;
            const entry = {
              key,
              label,
              originY,
              dataUrl,
              displayScale,
              createdAt: Date.now(),
            };
            const store = await tx("readwrite");
            await new Promise((resolve, reject) => {
              const request = store.add(entry);
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
            return { ...entry, dataUrl: entry.dataUrl, displayScale, isCustom: true };
          },
          async deleteTile(key) {
            const store = await tx("readwrite");
            await new Promise((resolve, reject) => {
              const request = store.openCursor();
              request.onsuccess = () => {
                const cursor = request.result;
                if (!cursor) return resolve();
                if (cursor.value.key === key) {
                  cursor.delete();
                  resolve();
                } else {
                  cursor.continue();
                }
              };
              request.onerror = () => reject(request.error);
            });
          },
          async savePlacement(key, tileKey, col, row) {
            const db = await dbPromise;
            const store = db.transaction(PLACEMENTS_STORE, "readwrite").objectStore(PLACEMENTS_STORE);
            await new Promise((resolve, reject) => {
              const request = store.put({ key, tileKey, col, row });
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
          },
          async deletePlacement(key) {
            const db = await dbPromise;
            const store = db.transaction(PLACEMENTS_STORE, "readwrite").objectStore(PLACEMENTS_STORE);
            await new Promise((resolve, reject) => {
              const request = store.delete(key);
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
          },
          async getPlacements() {
            const db = await dbPromise;
            const store = db.transaction(PLACEMENTS_STORE, "readonly").objectStore(PLACEMENTS_STORE);
            return await new Promise((resolve, reject) => {
              const request = store.getAll();
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
            });
          },
        };
      }
    </script>
  </body>
</html>
