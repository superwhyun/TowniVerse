<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TowniVerse Isometric Builder</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --bg: #0f141a;
        --panel: rgba(15, 20, 26, 0.9);
        --accent: #ffe29a;
        --grid: rgba(255, 255, 255, 0.25);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #1c2733, #090c10 60%);
        color: #f2f6fb;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 1.5rem 2rem 0.5rem;
      }

      h1 {
        font-size: 1.75rem;
        margin: 0 0 0.25rem;
        letter-spacing: 0.05em;
      }

      p.subtitle {
        margin: 0;
        color: rgba(242, 246, 251, 0.7);
      }

      main {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(0, 4fr) minmax(240px, 1fr);
        gap: 1.25rem;
        padding: 0 2rem 1.5rem;
        min-height: calc(100vh - 140px);
        align-items: stretch;
      }

      #game-wrapper {
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 25px 65px rgba(0, 0, 0, 0.45);
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
      }

      aside {
        background: var(--panel);
        border-radius: 20px;
        padding: 1.5rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        min-height: 0;
      }

      aside > div:first-child {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
      }

      #tile-palette {
        overflow-y: auto;
        flex: 1;
        min-height: 0;
      }

      .panel-title {
        font-weight: 600;
        letter-spacing: 0.06em;
        margin-bottom: 0.3rem;
      }

      #tile-palette {
        display: grid;
        grid-template-columns: repeat(auto-fill, 100px);
        gap: 0.75rem;
      }

      .tile-swatch {
        position: relative;
        width: 100px;
        height: 100px;
        background: transparent;
        border: 1px dashed rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        cursor: pointer;
        transition: transform 120ms ease, border-color 120ms ease;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.02);
      }

      .tile-swatch .tile-remove {
        position: absolute;
        top: 0.35rem;
        right: 0.35rem;
        width: 1.4rem;
        height: 1.4rem;
        border: none;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        cursor: pointer;
        font-weight: 700;
      }

      .tile-swatch .tile-size {
        position: absolute;
        top: 0.35rem;
        left: 0.35rem;
        padding: 0.15rem 0.35rem;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.75);
        color: rgba(255, 255, 255, 0.9);
        font-size: 0.7rem;
        font-weight: 600;
        line-height: 1;
        pointer-events: none;
      }

      .tile-swatch:focus-visible {
        outline: 2px solid var(--accent);
      }

      .tile-swatch.active {
        border-style: solid;
        border-color: var(--accent);
        transform: translateY(-3px);
      }

      .tile-swatch .diamond {
        position: absolute;
        inset: 15%;
        clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);
        border: 2px solid rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(2px);
      }

      .tile-swatch img {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 90%;
        height: 90%;
        transform: translate(-50%, -50%);
        object-fit: contain;
        pointer-events: none;
      }

      .tile-swatch .diamond.lot {
        background: linear-gradient(135deg, #d1e2c3, #a2c28a);
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.35);
      }

      .tile-swatch .diamond .building {
        position: absolute;
        width: 55%;
        height: 70%;
        left: 50%;
        bottom: 8%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #f9d4b3, #f6b68a);
        border-radius: 6px 6px 12px 12px;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35);
      }

      .tile-swatch .diamond .building::before {
        content: "";
        position: absolute;
        inset: -18% 4% 60%;
        background: linear-gradient(135deg, #fc9d6c, #e0703a);
        clip-path: polygon(50% 0, 100% 60%, 50% 90%, 0 60%);
      }

      .instructions {
        font-size: 0.95rem;
        line-height: 1.5;
        color: rgba(255, 255, 255, 0.8);
      }

      .instructions kbd {
        display: inline-block;
        padding: 0.15rem 0.4rem;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.45);
        font-size: 0.85rem;
        margin: 0 0.1rem;
      }

      .upload-panel {
        background: rgba(255, 255, 255, 0.04);
        border-radius: 16px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .upload-panel label {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.85);
      }

      .upload-panel input {
        padding: 0.4rem 0.6rem;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(0, 0, 0, 0.25);
        color: #fff;
      }

      .upload-panel #export-btn,
      .upload-panel #import-btn {
        padding: 0.45rem 0.75rem;
        border-radius: 10px;
        border: none;
        background: linear-gradient(120deg, #ffa75e, #ff6d6d);
        color: #0f141a;
        font-weight: 600;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }

      .upload-panel #import-btn {
        background: linear-gradient(120deg, #6d9aff, #5e7aff);
      }

      .upload-panel #export-btn:hover,
      .upload-panel #import-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 18px rgba(255, 113, 99, 0.4);
      }

      .upload-panel #import-btn:hover {
        box-shadow: 0 6px 18px rgba(109, 154, 255, 0.4);
      }

      .grid-size-toggle {
        display: flex;
        gap: 0.5rem;
      }

      .size-btn {
        flex: 1;
        padding: 0.6rem;
        border-radius: 8px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.3);
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 150ms ease;
        box-shadow: none;
      }

      .size-btn:hover:not(.active) {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.35);
        color: rgba(255, 255, 255, 0.7);
      }

      .size-btn.active {
        background: linear-gradient(120deg, #ffa75e, #ff6d6d);
        border-color: rgba(255, 167, 94, 0.8);
        color: #0f141a;
        box-shadow: 0 4px 12px rgba(255, 167, 94, 0.4);
        transform: translateY(-1px);
      }

      #calibration-modal {
        position: fixed;
        inset: 0;
        background: rgba(5, 8, 12, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        opacity: 0;
        pointer-events: none;
        transition: opacity 180ms ease;
      }

      #calibration-modal.visible {
        opacity: 1;
        pointer-events: auto;
      }

      .calibration-card {
        background: #10161f;
        border-radius: 18px;
        padding: 1.25rem;
        width: min(640px, 90vw);
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 35px 50px rgba(0, 0, 0, 0.5);
      }

      .calibration-card h3 {
        margin: 0;
      }

      #calibration-canvas {
        width: 100%;
        height: auto;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        background: #0c1118;
        cursor: crosshair;
      }

      .calibration-actions {
        display: flex;
        gap: 0.5rem;
        justify-content: flex-end;
      }

      .calibration-actions button {
        padding: 0.45rem 0.8rem;
        border-radius: 10px;
        border: none;
        cursor: pointer;
      }

      #calibration-confirm {
        background: linear-gradient(120deg, #7cffc4, #5dcfff);
        color: #0c1118;
        font-weight: 600;
      }

      #calibration-reset,
      #calibration-skip {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      #drop-zone {
        border: 2px dashed rgba(255, 255, 255, 0.4);
        border-radius: 14px;
        padding: 1rem;
        text-align: center;
        color: rgba(255, 255, 255, 0.85);
        transition: border-color 150ms ease, color 150ms ease;
        cursor: pointer;
      }

      #drop-zone.dragover {
        border-color: var(--accent);
        color: var(--accent);
      }

      #upload-status {
        min-height: 1.3rem;
        font-size: 0.85rem;
        color: var(--accent);
      }

      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }

        aside {
          order: -1;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>TowniVerse Isometric Builder</h1>
      <p class="subtitle">
        투명 배경의 isometric 타일을 선택해서 와이어 격자 위에 마을을 쌓아 올려보세요.
      </p>
    </header>
    <main>
      <section id="game-wrapper"></section>
      <aside>
        <div>
          <div class="panel-title">타일 샘플</div>
          <input id="tile-search" type="text" placeholder="타일 검색..." style="width: 100%; padding: 0.5rem; margin-bottom: 0.75rem; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.25); background: rgba(0, 0, 0, 0.25); color: #fff;" />
          <div id="tile-palette"></div>
          <div id="tile-pagination" style="display: flex; justify-content: center; align-items: center; gap: 0.5rem; margin-top: 0.75rem; font-size: 0.85rem;">
            <button id="prev-page" style="padding: 0.3rem 0.6rem; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.3); background: rgba(0, 0, 0, 0.3); color: #fff; cursor: pointer;">◀</button>
            <span id="page-info" style="color: rgba(255, 255, 255, 0.7);"></span>
            <button id="next-page" style="padding: 0.3rem 0.6rem; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.3); background: rgba(0, 0, 0, 0.3); color: #fff; cursor: pointer;">▶</button>
          </div>
        </div>
        <div class="upload-panel">
          <div class="panel-title">새 PNG 업로드</div>
          <label>
            라벨
            <input id="upload-label" type="text" placeholder="예: 새 주택" />
          </label>
          <label>
            격자 크기
            <div class="grid-size-toggle">
              <button type="button" class="size-btn active" data-size="1">1x1</button>
              <button type="button" class="size-btn" data-size="2">2x2</button>
            </div>
          </label>
          <input id="file-input" type="file" accept="image/png" hidden />
          <div id="drop-zone">PNG 파일을 드래그하거나 클릭해 업로드</div>
          <div id="upload-status"></div>
          <button type="button" id="export-btn">ZIP으로 내보내기</button>
          <button type="button" id="import-btn">URL에서 가져오기</button>
          <small>※ 업로드한 타일은 브라우저에만 저장됩니다. originY는 자동 계산됩니다.</small>
        </div>
      </aside>
    </main>

    <div id="calibration-modal">
      <div class="calibration-card">
        <h3>마름모 기준 맞추기</h3>
        <p id="calibration-hint">상단 꼭짓점을 클릭하세요.</p>
        <canvas id="calibration-canvas" width="520" height="360"></canvas>
        <div class="calibration-actions">
          <button type="button" id="calibration-reset">다시 찍기</button>
          <button type="button" id="calibration-skip">건너뛰기</button>
          <button type="button" id="calibration-confirm" disabled>확인</button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
      const TILE_WIDTH = 256;
      const TILE_HEIGHT = 128;
      const GRID_BUFFER = 3;
      const WORLD_BOUNDS = 200000;
      const WHEEL_SCROLL_FACTOR = 0.15;
      const gridOrigin = { x: 0, y: 0 };

      let builtInTiles = [];

      const tileStore = createTileStore();
      const calibrator = createCalibrator();
      const uploadElements = {
        dropZone: document.getElementById("drop-zone"),
        fileInput: document.getElementById("file-input"),
        labelInput: document.getElementById("upload-label"),
        status: document.getElementById("upload-status"),
      };
      let selectedGridSize = 1; // 1 또는 2
      const exportButton = document.getElementById("export-btn");
      const importButton = document.getElementById("import-btn");

      const paletteContainer = document.getElementById("tile-palette");
      paletteContainer.textContent = "타일을 불러오는 중...";

      let palette = [];
      let filteredPalette = [];
      let tileDefinitions = new Map();
      let activeTileKey = null;
      const placedTiles = new Map();
      const spriteCache = new Map();
      const runtimeUrls = new Map();
      let game = null;

      // 페이지네이션 설정
      const TILES_PER_PAGE = 12;
      let currentPage = 0;
      let searchQuery = "";

      paletteContainer.addEventListener("click", (event) => {
        const button = event.target.closest(".tile-swatch");
        if (!button) return;
        setActiveTile(button.dataset.tileKey);
      });

      init();

      async function init() {
        setupGridSizeToggle();
        setupUploader();
        setupExportButton();
        setupImportButton();
        setupSearch();
        setupPagination();
        builtInTiles = await loadManifestTiles();
        await loadPaletteAndStart();

        // 저장된 배치 로드
        await loadSavedPlacements();
      }

      function setupSearch() {
        const searchInput = document.getElementById("tile-search");
        searchInput.addEventListener("input", (e) => {
          searchQuery = e.target.value.toLowerCase();
          currentPage = 0;
          filterAndRenderPalette();
        });
      }

      function setupPagination() {
        const prevBtn = document.getElementById("prev-page");
        const nextBtn = document.getElementById("next-page");

        prevBtn.addEventListener("click", () => {
          if (currentPage > 0) {
            currentPage--;
            filterAndRenderPalette();
          }
        });

        nextBtn.addEventListener("click", () => {
          const totalPages = Math.ceil(filteredPalette.length / TILES_PER_PAGE);
          if (currentPage < totalPages - 1) {
            currentPage++;
            filterAndRenderPalette();
          }
        });
      }

      function filterAndRenderPalette() {
        // 검색어로 필터링
        if (searchQuery) {
          filteredPalette = palette.filter(tile =>
            tile.label.toLowerCase().includes(searchQuery) ||
            tile.key.toLowerCase().includes(searchQuery)
          );
        } else {
          filteredPalette = [...palette];
        }

        renderPalette();
        updatePaginationInfo();
      }

      function updatePaginationInfo() {
        const pageInfo = document.getElementById("page-info");
        const prevBtn = document.getElementById("prev-page");
        const nextBtn = document.getElementById("next-page");

        const totalPages = Math.ceil(filteredPalette.length / TILES_PER_PAGE);

        if (totalPages === 0) {
          pageInfo.textContent = "타일 없음";
          prevBtn.disabled = true;
          nextBtn.disabled = true;
        } else {
          pageInfo.textContent = `${currentPage + 1} / ${totalPages}`;
          prevBtn.disabled = currentPage === 0;
          nextBtn.disabled = currentPage >= totalPages - 1;
        }

        prevBtn.style.opacity = prevBtn.disabled ? "0.3" : "1";
        nextBtn.style.opacity = nextBtn.disabled ? "0.3" : "1";
        prevBtn.style.cursor = prevBtn.disabled ? "not-allowed" : "pointer";
        nextBtn.style.cursor = nextBtn.disabled ? "not-allowed" : "pointer";
      }

      function setupGridSizeToggle() {
        const buttons = document.querySelectorAll('.size-btn');
        console.log('Found buttons:', buttons.length);
        buttons.forEach(button => {
          button.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Button clicked:', button.dataset.size);
            buttons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            selectedGridSize = parseInt(button.dataset.size);
            console.log('Selected grid size:', selectedGridSize);
          });
        });
      }

      async function loadSavedPlacements() {
        try {
          const placements = await tileStore.getPlacements();

          // 같은 타일키를 가진 셀들을 그룹화하여 기준점(가장 작은 col, row) 찾기
          const tileGroups = new Map();

          placements.forEach(({ key, tileKey, col, row }) => {
            if (!tileGroups.has(tileKey)) {
              tileGroups.set(tileKey, []);
            }
            tileGroups.get(tileKey).push({ key, col, row });
          });

          // 각 그룹에서 연결된 셀들을 찾고 기준점 계산
          const processedCells = new Set();

          placements.forEach(({ key, tileKey, col, row }) => {
            if (processedCells.has(key)) return;

            const tileDef = tileDefinitions.get(tileKey);
            const gridWidth = tileDef?.gridWidth || 1;
            const gridHeight = tileDef?.gridHeight || 1;

            // 이 셀과 연결된 모든 셀 찾기 (같은 타일키이면서 인접한 gridWidth x gridHeight 영역)
            const connectedCells = [];
            for (let r = 0; r < gridHeight; r++) {
              for (let c = 0; c < gridWidth; c++) {
                const testKey = `${col + c}-${row + r}`;
                const testPlacement = placements.find(p => p.key === testKey && p.tileKey === tileKey);
                if (testPlacement) {
                  connectedCells.push(testPlacement);
                }
              }
            }

            // 연결된 셀들이 gridWidth x gridHeight만큼 있으면 현재 셀이 기준점
            if (connectedCells.length === gridWidth * gridHeight) {
              const baseCol = col;
              const baseRow = row;

              // 모든 연결된 셀에 대해 placedTiles 설정
              connectedCells.forEach(({ key: cellKey, col: cellCol, row: cellRow }) => {
                processedCells.add(cellKey);
                placedTiles.set(cellKey, {
                  tileKey,
                  grid: { col: cellCol, row: cellRow },
                  isBase: cellCol === baseCol && cellRow === baseRow,
                  baseCol,
                  baseRow,
                  gridWidth,
                  gridHeight,
                });
              });
            }
          });

          console.log(`Loaded ${placements.length} placements from storage`);

          // 게임이 이미 시작되었으면 화면 갱신
          if (game) {
            const activeScene = game.scene.getAt(0);
            if (activeScene) {
              refreshSceneView(activeScene);
            }
          }
        } catch (error) {
          console.error("Failed to load placements:", error);
        }
      }

      async function loadManifestTiles() {
        // 기본 타일 제거됨 - 빈 배열 반환
        return [];
      }

      async function loadPaletteAndStart() {
        const customTiles = await tileStore.getTiles();
        runtimeUrls.forEach((url) => URL.revokeObjectURL(url));
        runtimeUrls.clear();

        // 빈 타일 필터링 (dataUrl이나 url이 없는 타일 제외)
        palette = [...builtInTiles, ...customTiles].filter(tile => {
          if (tile.isCustom) {
            return tile.dataUrl && tile.dataUrl.length > 0;
          } else {
            return tile.url || tile.file;
          }
        });

        if (!palette.length) {
          paletteContainer.textContent = "등록된 타일이 없습니다.";
          return;
        }

        palette.forEach((tile) => {
          // gridWidth, gridHeight 기본값 설정
          tile.gridWidth = tile.gridWidth ?? 1;
          tile.gridHeight = tile.gridHeight ?? 1;

          if (tile.isCustom) {
            tile.previewUrl = tile.dataUrl;
            const blob = dataURLToBlob(tile.dataUrl);
            const runtime = URL.createObjectURL(blob);
            runtimeUrls.set(tile.key, runtime);
            tile.runtimeUrl = runtime;
            tile.isSvg = false;
          } else {
            const url = tile.url || tile.file;
            tile.previewUrl = url;
            tile.runtimeUrl = url;
            tile.isSvg = url?.toLowerCase().endsWith(".svg");
          }
        });

        tileDefinitions = new Map(palette.map((tile) => [tile.key, tile]));
        if (!activeTileKey || !tileDefinitions.has(activeTileKey)) {
          activeTileKey = palette[0].key;
        }

        filterAndRenderPalette();
        if (!game) {
          startGame();
        } else {
          await registerMissingTextures();
        }
      }

      function renderPalette() {
        paletteContainer.innerHTML = "";

        // 현재 페이지의 타일만 표시
        const startIdx = currentPage * TILES_PER_PAGE;
        const endIdx = startIdx + TILES_PER_PAGE;
        const tilesToShow = filteredPalette.slice(startIdx, endIdx);

        if (tilesToShow.length === 0) {
          paletteContainer.textContent = searchQuery ? "검색 결과가 없습니다." : "등록된 타일이 없습니다.";
          return;
        }

        tilesToShow.forEach((tile) => {
          const button = document.createElement("button");
          button.className = "tile-swatch" + (tile.key === activeTileKey ? " active" : "");
          button.type = "button";
          button.dataset.tileKey = tile.key;

          const preview = document.createElement("img");
          preview.src = tile.previewUrl;
          preview.alt = tile.label;
          preview.loading = "lazy";
          preview.decoding = "async";
          preview.draggable = false;

          button.appendChild(preview);

          // 그리드 크기 표시 추가
          const sizeLabel = document.createElement("span");
          sizeLabel.className = "tile-size";
          const gridWidth = tile.gridWidth || 1;
          const gridHeight = tile.gridHeight || 1;
          sizeLabel.textContent = `${gridWidth}x${gridHeight}`;
          button.appendChild(sizeLabel);

          if (tile.isCustom) {
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.className = "tile-remove";
            removeBtn.textContent = "×";
            removeBtn.title = "타일 삭제";
            removeBtn.addEventListener("click", async (event) => {
              event.stopPropagation();
              await tileStore.deleteTile(tile.key);
              if (activeTileKey === tile.key) {
                activeTileKey = palette[0]?.key || null;
              }
              await loadPaletteAndStart();
            });
            button.appendChild(removeBtn);
          }
          paletteContainer.appendChild(button);
        });
      }

      function setActiveTile(tileKey) {
        if (!tileDefinitions.has(tileKey)) return;
        activeTileKey = tileKey;
        document
          .querySelectorAll(".tile-swatch")
          .forEach((el) => el.classList.toggle("active", el.dataset.tileKey === tileKey));
      }

      function startGame() {
        if (game) {
          return;
        }

        const scene = {
          preload: preloadScene,
          create: createScene,
          update: updateScene,
        };

        const config = {
          type: Phaser.AUTO,
          parent: "game-wrapper",
          width: 1600,
          height: 900,
          backgroundColor: "rgba(0,0,0,0)",
          transparent: true,
          scene,
          pixelArt: true,
          scale: {
            parent: "game-wrapper",
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width: '100%',
            height: '100%',
          },
        };
        game = new Phaser.Game(config);
      }

      function preloadScene() {
        palette.forEach((tile) => {
          const textureScale = tile.textureScale ?? tile.scale ?? 1;
          const assetUrl = tile.runtimeUrl;
          if (tile.isSvg && this.load.svg) {
            this.load.svg(tile.key, assetUrl, { scale: textureScale });
          } else {
            this.load.image(tile.key, assetUrl);
          }
        });
      }

      function createScene() {
        this.cameras.main.setBounds(
          -WORLD_BOUNDS,
          -WORLD_BOUNDS,
          WORLD_BOUNDS * 2,
          WORLD_BOUNDS * 2
        );
        this.cameras.main.setZoom(1);
        this.cameras.main.setBackgroundColor("rgba(0,0,0,0)");
        this.cameras.main.centerOn(0, 0);

        this.gridGraphics = this.add.graphics();
        this.gridGraphics.setDepth(-1000);

        this.previewGraphics = this.add.graphics();
        this.previewGraphics.setDepth(10000);

        palette.forEach((tile) => {
          if (this.textures.exists(tile.key)) {
            tile.loaded = true;
          }
        });

        let resizeDebounceTimer = null;
        this.scale.on("resize", () => {
          // 리사이즈 이벤트 디바운싱으로 과도한 호출 방지
          if (resizeDebounceTimer) {
            clearTimeout(resizeDebounceTimer);
          }
          resizeDebounceTimer = setTimeout(() => {
            refreshSceneView(this);
            updateDepths(this.cameras.main);
            resizeDebounceTimer = null;
          }, 100);
        });

        this.cursors = this.input.keyboard.createCursorKeys();

        // 마우스 휠로 줌 인/아웃
        this.input.on("wheel", (pointer, gameObjects, deltaX, deltaY, deltaZ, event) => {
          const cam = this.cameras.main;
          const zoomAmount = deltaY > 0 ? -0.02 : 0.02; // 민감도 낮춤: 위로 스크롤 = 확대, 아래로 = 축소
          const newZoom = Phaser.Math.Clamp(cam.zoom + zoomAmount, 0.3, 3);
          cam.setZoom(newZoom);
          refreshSceneView(this);
          updateDepths(cam);
          event?.preventDefault();
        });

        // 좌클릭 드래그로 화면 이동
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;

        this.input.on("pointerdown", (pointer) => {
          if (pointer.leftButtonDown()) {
            this.isDragging = true;
            this.dragStartX = pointer.x;
            this.dragStartY = pointer.y;
          }
        });

        this.input.on("pointerup", (pointer) => {
          this.isDragging = false;
        });

        this.input.on("pointermove", (pointer) => {
          if (this.isDragging) {
            const cam = this.cameras.main;
            const deltaX = (pointer.x - this.dragStartX) / cam.zoom;
            const deltaY = (pointer.y - this.dragStartY) / cam.zoom;
            cam.scrollX -= deltaX;
            cam.scrollY -= deltaY;
            this.dragStartX = pointer.x;
            this.dragStartY = pointer.y;
            refreshSceneView(this);
            updateDepths(cam);
            return; // 드래그 중에는 타일 프리뷰 표시 안함
          }

          // 타일 프리뷰 표시 (드래그 중이 아닐 때만)
          if (!activeTileKey) {
            this.previewGraphics.clear();
            return;
          }
          const worldPoint = pointer.positionToCamera(this.cameras.main);
          const gridPoint = screenToGrid(worldPoint.x, worldPoint.y);
          if (!gridPoint) {
            this.previewGraphics.clear();
            return;
          }

          const tileDef = tileDefinitions.get(activeTileKey);
          if (!tileDef) return;

          const gridWidth = tileDef.gridWidth || 1;
          const gridHeight = tileDef.gridHeight || 1;
          const { baseCol, baseRow } = getPlacementBase(
            gridPoint.col,
            gridPoint.row,
            gridWidth,
            gridHeight
          );

          // 빨간색 테두리로 프리뷰 그리기
          this.previewGraphics.clear();
          this.previewGraphics.lineStyle(3, 0xff0000, 0.8);

          for (let r = 0; r < gridHeight; r++) {
            for (let c = 0; c < gridWidth; c++) {
              const pos = gridToScreen(baseCol + c, baseRow + r);
              const diamond = [
                { x: pos.x, y: pos.y - TILE_HEIGHT / 2 },
                { x: pos.x + TILE_WIDTH / 2, y: pos.y },
                { x: pos.x, y: pos.y + TILE_HEIGHT / 2 },
                { x: pos.x - TILE_WIDTH / 2, y: pos.y },
              ];
              this.previewGraphics.beginPath();
              this.previewGraphics.moveTo(diamond[0].x, diamond[0].y);
              for (let i = 1; i < diamond.length; i++) {
                this.previewGraphics.lineTo(diamond[i].x, diamond[i].y);
              }
              this.previewGraphics.closePath();
              this.previewGraphics.strokePath();
            }
          }
        });

        this.clickStartTime = 0;
        this.clickStartPos = { x: 0, y: 0 };

        this.input.on("pointerdown", async (pointer) => {
          // 좌클릭 시작 시간과 위치 기록 (클릭 vs 드래그 구분용)
          if (pointer.leftButtonDown()) {
            this.clickStartTime = Date.now();
            this.clickStartPos = { x: pointer.x, y: pointer.y };
          }
        });

        this.input.on("pointerup", async (pointer) => {
          const worldPoint = pointer.positionToCamera(this.cameras.main);
          const gridPoint = screenToGrid(worldPoint.x, worldPoint.y);

          // 좌클릭 종료 시: 드래그가 아닌 클릭이었다면 타일 배치/삭제 처리
          if (pointer.leftButtonReleased()) {
            const clickDuration = Date.now() - this.clickStartTime;
            const distance = Phaser.Math.Distance.Between(
              this.clickStartPos.x, this.clickStartPos.y,
              pointer.x, pointer.y
            );

            // 200ms 이내이고 5픽셀 이내 이동이면 클릭으로 간주
            if (clickDuration < 200 && distance < 5 && gridPoint) {
              // 타일 배치/토글
              if (!activeTileKey) return;

              const tileDef = tileDefinitions.get(activeTileKey);
              if (!tileDef) return;

              const gridWidth = tileDef.gridWidth || 1;
              const gridHeight = tileDef.gridHeight || 1;
              const { baseCol, baseRow } = getPlacementBase(
                gridPoint.col,
                gridPoint.row,
                gridWidth,
                gridHeight
              );
              const baseKey = `${baseCol}-${baseRow}`;

              // 클릭한 위치가 같은 타일인지 확인 (토글 삭제)
              const existing = placedTiles.get(baseKey);
              if (existing && existing.tileKey === activeTileKey && existing.isBase) {
                // 타일 제거: 모든 연결된 격자 제거
                const gw = existing.gridWidth || 1;
                const gh = existing.gridHeight || 1;
                for (let r = 0; r < gh; r++) {
                  for (let c = 0; c < gw; c++) {
                    const key = `${baseCol + c}-${baseRow + r}`;
                    placedTiles.delete(key);
                    await tileStore.deletePlacement(key);
                  }
                }
                // 스프라이트 제거 (기준점에만 있음)
                const sprite = spriteCache.get(baseKey);
                if (sprite) {
                  sprite.destroy();
                  spriteCache.delete(baseKey);
                }
                refreshSceneView(this);
                return;
              }

              // 충돌 체크: 배치하려는 모든 격자가 비어있는지 확인
              for (let r = 0; r < gridHeight; r++) {
                for (let c = 0; c < gridWidth; c++) {
                  const key = `${baseCol + c}-${baseRow + r}`;
                  if (placedTiles.has(key)) {
                    console.log("충돌: 이미 타일이 배치되어 있습니다.");
                    return; // 충돌 발생, 배치 취소
                  }
                }
              }

              // 타일 배치: 모든 격자에 점유 정보 저장
              for (let r = 0; r < gridHeight; r++) {
                for (let c = 0; c < gridWidth; c++) {
                  const key = `${baseCol + c}-${baseRow + r}`;
                  placedTiles.set(key, {
                    tileKey: activeTileKey,
                    grid: { col: baseCol + c, row: baseRow + r },
                    isBase: r === 0 && c === 0, // 좌측 상단이 기준점
                    baseCol,
                    baseRow,
                    gridWidth,
                    gridHeight,
                  });
                  await tileStore.savePlacement(key, activeTileKey, baseCol + c, baseRow + r);
                }
              }

              refreshSceneView(this);
            }
          }

          // 우클릭: 타일 삭제
          if (pointer.rightButtonReleased() && gridPoint) {
            const clickedKey = `${gridPoint.col}-${gridPoint.row}`;
            const clickedTile = placedTiles.get(clickedKey);

            if (clickedTile) {
              // 기준점 찾기
              const baseKey = `${clickedTile.baseCol}-${clickedTile.baseRow}`;
              const baseTile = placedTiles.get(baseKey);

              if (baseTile) {
                const gw = baseTile.gridWidth || 1;
                const gh = baseTile.gridHeight || 1;

                // 모든 연결된 격자 제거
                for (let r = 0; r < gh; r++) {
                  for (let c = 0; c < gw; c++) {
                    const key = `${clickedTile.baseCol + c}-${clickedTile.baseRow + r}`;
                    placedTiles.delete(key);
                    await tileStore.deletePlacement(key);
                  }
                }

                // 스프라이트 제거
                const sprite = spriteCache.get(baseKey);
                if (sprite) {
                  sprite.destroy();
                  spriteCache.delete(baseKey);
                }

                refreshSceneView(this);
              }
            }
          }
        });

        // 우클릭 컨텍스트 메뉴 방지
        this.input.mouse.disableContextMenu();

        refreshSceneView(this);
      }

      function updateScene(_, delta) {
        if (!this.cursors) return;
        const cam = this.cameras.main;
        const speed = 0.25 * delta;
        let moved = false;

        if (this.cursors.left.isDown) {
          cam.scrollX -= speed;
          moved = true;
        } else if (this.cursors.right.isDown) {
          cam.scrollX += speed;
          moved = true;
        }

        if (this.cursors.up.isDown) {
          cam.scrollY -= speed;
          moved = true;
        } else if (this.cursors.down.isDown) {
          cam.scrollY += speed;
          moved = true;
        }

        if (moved) {
          refreshSceneView(this);
          updateDepths(cam);
        }
      }

      function refreshSceneView(scene) {
        const bounds = getVisibleBounds(scene.cameras.main, GRID_BUFFER);
        drawWireGrid(scene, bounds);
        syncVisibleTiles(scene, bounds);
      }

      function updateDepths(camera) {
        const offset = camera.scrollY;
        spriteCache.forEach((sprite) => {
          sprite.setDepth(sprite.y - offset);
        });
      }

      function syncVisibleTiles(scene, bounds) {
        spriteCache.forEach((sprite, key) => {
          const data = placedTiles.get(key);
          if (!data || !data.isBase || !isWithinBounds(data.grid, bounds)) {
            sprite.destroy();
            spriteCache.delete(key);
          }
        });

        placedTiles.forEach((data, key) => {
          // 기준점(isBase)인 타일만 렌더링
          if (!data.isBase) return;
          if (!isWithinBounds(data.grid, bounds)) return;

          if (!tileDefinitions.get(data.tileKey)?.loaded) {
            return;
          }

          let sprite = spriteCache.get(key);
          if (!sprite) {
            const tileDef = tileDefinitions.get(data.tileKey);
            if (!tileDef) return;

            // 기준점(좌측 상단)에서 스프라이트 배치
            // 다중 격자 타일의 경우, 중심 위치에 스프라이트 배치
            const gridWidth = data.gridWidth || 1;
            const gridHeight = data.gridHeight || 1;
            // 발판의 좌우 끝(iso 기준)을 구해 중간 지점에 스프라이트를 두어야 정확히 격자와 맞음
            const baseCol = data.baseCol ?? data.grid.col;
            const baseRow = data.baseRow ?? data.grid.row;

            // 2x2 타일의 경우 우하향으로 0.5 타일 이동
            const rowAdjustment = (gridWidth === 2 && gridHeight === 2) ? 0.75 : 0;
            const colAdjustment = (gridWidth === 2 && gridHeight === 2) ? -0.75 : 0;

            const bottomLeft = gridToScreen(baseCol, baseRow + gridHeight - 1 + rowAdjustment);
            const bottomRight = gridToScreen(
              baseCol + gridWidth - 1 + rowAdjustment,
              baseRow + gridHeight - 1 + colAdjustment
            );
            const world = {
              x: (bottomLeft.x + bottomRight.x) / 2,
              y: (bottomLeft.y + bottomRight.y) / 2,
            };
            sprite = scene.add.image(world.x, world.y, data.tileKey);
            sprite.setOrigin(0.5, tileDef.originY ?? 0.5);
            const targetWidth = tileDef.fitWidth ?? TILE_WIDTH;
            const autoScale = sprite.width ? targetWidth / sprite.width : 1;
            const scale = tileDef.displayScale ?? autoScale;
            if (scale && Math.abs(scale - 1) > 0.001) {
              sprite.setScale(scale);
            }
            spriteCache.set(key, sprite);
            // 새로 생성된 스프라이트만 depth 설정
            sprite.setDepth(sprite.y - scene.cameras.main.scrollY);
          }
        });
      }

      function drawWireGrid(scene, bounds) {
        if (!scene.gridGraphics) return;
        scene.gridGraphics.clear();
        scene.gridGraphics.lineStyle(1.5, 0xffffff, 0.22);

        for (let row = bounds.minRow; row <= bounds.maxRow; row++) {
          for (let col = bounds.minCol; col <= bounds.maxCol; col++) {
            const center = gridToScreen(col, row);
            const diamond = diamondPoints(center.x, center.y);
            scene.gridGraphics.strokePoints(diamond, true);
          }
        }
      }

      function diamondPoints(x, y) {
        return diamondPointsScaled(x, y);
      }

      function diamondPointsScaled(x, y, width = TILE_WIDTH, height = TILE_HEIGHT) {
        return [
          new Phaser.Math.Vector2(x, y - height / 2),
          new Phaser.Math.Vector2(x + width / 2, y),
          new Phaser.Math.Vector2(x, y + height / 2),
          new Phaser.Math.Vector2(x - width / 2, y),
        ];
      }

      function gridToScreen(col, row) {
        return {
          x: gridOrigin.x + (col - row) * (TILE_WIDTH / 2),
          y: gridOrigin.y + (col + row) * (TILE_HEIGHT / 2),
        };
      }

      function screenToGrid(x, y) {
        const grid = screenToGridFloat(x, y);
        const col = Math.round(grid.col);
        const row = Math.round(grid.row);

        const world = gridToScreen(col, row);
        const diamond = diamondPoints(world.x, world.y);
        const polygon = new Phaser.Geom.Polygon(diamond);
        if (!Phaser.Geom.Polygon.Contains(polygon, x, y)) {
          return null;
        }
        return { col, row };
      }

      function screenToGridFloat(x, y) {
        const cx = x - gridOrigin.x;
        const cy = y - gridOrigin.y;
        const col = (cx / (TILE_WIDTH / 2) + cy / (TILE_HEIGHT / 2)) / 2;
        const row = (cy / (TILE_HEIGHT / 2) - cx / (TILE_WIDTH / 2)) / 2;
        return { col, row };
      }

      function getPlacementBase(anchorCol, anchorRow, gridWidth = 1, gridHeight = 1) {
        const safeWidth = Math.max(1, gridWidth);
        const safeHeight = Math.max(1, gridHeight);
        // anchor는 타일의 하단 중앙 마름모, base는 좌측 상단 셀
        const baseRow = anchorRow - (safeHeight - 1);
        const baseCol = anchorCol - Math.round((safeWidth - 1) / 2);
        return { baseCol, baseRow };
      }

      function getVisibleBounds(camera, padding = 0) {
        const view = camera.worldView;
        const corners = [
          { x: view.left, y: view.top },
          { x: view.right, y: view.top },
          { x: view.right, y: view.bottom },
          { x: view.left, y: view.bottom },
        ];
        const cols = [];
        const rows = [];
        corners.forEach((corner) => {
          const grid = screenToGridFloat(corner.x, corner.y);
          cols.push(grid.col);
          rows.push(grid.row);
        });

        const minCol = Math.floor(Math.min(...cols)) - padding;
        const maxCol = Math.ceil(Math.max(...cols)) + padding;
        const minRow = Math.floor(Math.min(...rows)) - padding;
        const maxRow = Math.ceil(Math.max(...rows)) + padding;
        return { minCol, maxCol, minRow, maxRow };
      }

      function isWithinBounds(grid, bounds) {
        return (
          grid.col >= bounds.minCol &&
          grid.col <= bounds.maxCol &&
          grid.row >= bounds.minRow &&
          grid.row <= bounds.maxRow
        );
      }

      function setupUploader() {
        const {
          dropZone,
          fileInput,
          labelInput,
          status,
        } = uploadElements;
        if (!dropZone || !fileInput) return;

        const stop = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        ["dragenter", "dragover"].forEach((evt) => {
          dropZone?.addEventListener(evt, (event) => {
            stop(event);
            dropZone.classList.add("dragover");
          });
        });

        ["dragleave", "drop"].forEach((evt) => {
          dropZone?.addEventListener(evt, (event) => {
            stop(event);
            dropZone.classList.remove("dragover");
          });
        });

        dropZone.addEventListener("drop", (event) => {
          const file = event.dataTransfer?.files?.[0];
          if (file) {
            handleUpload(file);
          }
        });

        dropZone.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", () => {
          const file = fileInput.files?.[0];
          if (file) {
            handleUpload(file);
            fileInput.value = "";
          }
        });

        async function handleUpload(file) {
          if (!file.type.includes("png")) {
            status.textContent = "PNG 파일만 업로드 가능합니다.";
            return;
          }
          const label = (labelInput?.value || file.name.replace(/\.png$/i, "")).trim();
          const gridWidth = selectedGridSize;
          const gridHeight = selectedGridSize;
          status.textContent = "이미지 준비...";

          try {
            // 원본 이미지를 적당한 크기로 리사이즈 (calibration용)
            const basePreview = await resizePngBlob(file, TILE_WIDTH * 2);
            status.textContent = "보정 준비...";
            const calibration = await calibrator.open(basePreview, gridWidth, gridHeight);

            // calibration이 완료되면 이미 정확한 크기로 변환되어 있음
            const finalBlob = calibration?.blob || basePreview;
            const dataUrl = await blobToDataURL(finalBlob);

            // 이미지 크기를 확인하여 originY 계산
            const img = await loadImageElement(dataUrl);
            // 마름모 중심이 격자 중심에 와야 함
            // 기준점은 좌측 상단(row=0)이지만, 스프라이트는 row=(gridHeight-1)에 배치됨
            // 따라서 그림의 하단 마름모 중심이 이미지 하단에서 TILE_HEIGHT/2 위치에 와야 함
            // originY = (이미지 하단 - TILE_HEIGHT/2) / 이미지 높이
            const diamondCenterFromBottom = TILE_HEIGHT / 2;
            const calculatedOriginY = (img.height - diamondCenterFromBottom) / img.height;

            const savedTile = await tileStore.addTile({
              label,
              originY: calculatedOriginY,
              dataUrl,
              displayScale: 1,  // 이미 정확한 크기로 변환됨
              gridWidth,
              gridHeight,
            });
            status.textContent = "업로드 완료! 팔레트를 갱신합니다.";
            await loadPaletteAndStart();

            status.textContent = "텍스처 로딩 중...";
            await registerMissingTextures();

            // 새로 추가된 타일을 자동으로 선택
            setActiveTile(savedTile.key);

            // 디버깅: 타일 로드 상태 확인
            const loadedTile = tileDefinitions.get(savedTile.key);
            console.log("New tile loaded status:", loadedTile?.loaded, "key:", savedTile.key);

            status.textContent = "새 타일이 추가되었습니다. 클릭하여 배치하세요!";
          } catch (error) {
            status.textContent = "업로드 실패: " + error;
          }
        }
      }

      function setupExportButton() {
        if (!exportButton) return;
        exportButton.addEventListener("click", async () => {
          exportButton.disabled = true;
          const originalText = exportButton.textContent;
          exportButton.textContent = "내보내는 중...";
          try {
            await exportProject();
          } catch (error) {
            alert("내보내기 실패: " + error);
          } finally {
            exportButton.disabled = false;
            exportButton.textContent = originalText;
          }
        });
      }

      async function clearAllData() {
        // IndexedDB 모든 데이터 삭제
        await tileStore.clearAll();

        // 메모리상의 데이터 초기화
        palette = [];
        placedTiles.clear();
        spriteCache.forEach(sprite => sprite.destroy());
        spriteCache.clear();
        runtimeUrls.forEach(url => URL.revokeObjectURL(url));
        runtimeUrls.clear();
      }

      function setupImportButton() {
        if (!importButton) return;
        importButton.addEventListener("click", async () => {
          // 현재 주소와 포트를 기본값으로 설정
          const defaultUrl = `${window.location.protocol}//${window.location.host}/`;
          const url = prompt("타일셋 URL을 입력하세요:\n\n- ZIP 파일: https://example.com/tileset.zip\n- 디렉토리: https://example.com/tileset/\n\n※ 경고: 기존 타일이 모두 삭제됩니다!", defaultUrl);
          if (!url) return;

          // 확인 메시지
          if (!confirm("기존에 저장된 모든 타일과 배치가 삭제됩니다.\n계속하시겠습니까?")) {
            return;
          }

          importButton.disabled = true;
          const originalText = importButton.textContent;
          importButton.textContent = "가져오는 중...";
          try {
            // 기존 데이터 삭제
            await clearAllData();

            // ZIP 파일인지 디렉토리인지 확인
            if (url.toLowerCase().endsWith('.zip')) {
              await importFromZipUrl(url);
            } else {
              await importFromUrl(url);
            }
            alert("타일을 성공적으로 가져왔습니다!");
          } catch (error) {
            alert("가져오기 실패: " + error.message);
          } finally {
            importButton.disabled = false;
            importButton.textContent = originalText;
          }
        });
      }

      async function exportProject() {
        if (!window.JSZip) throw new Error("JSZip을 불러오지 못했습니다.");
        const zip = new JSZip();
        const manifest = {
          tiles: palette.map((tile) => ({
            key: tile.key,
            label: tile.label,
            originY: tile.originY,
            scale: tile.textureScale ?? tile.scale ?? 1,
            displayScale: tile.displayScale,
            gridWidth: tile.gridWidth ?? 1,
            gridHeight: tile.gridHeight ?? 1,
            file: `tiles/${tile.key}${tile.isSvg ? ".svg" : ".png"}`,
          })),
          placements: Array.from(placedTiles.values()).map((entry) => ({
            tileKey: entry.tileKey,
            col: entry.grid.col,
            row: entry.grid.row,
          })),
        };

        zip.file("manifest.json", JSON.stringify(manifest, null, 2));

        for (const tile of palette) {
          const ext = tile.isSvg ? ".svg" : ".png";
          const filename = `tiles/${tile.key}${ext}`;
          const blob = await getTileBlob(tile);
          zip.file(filename, blob);
        }

        const blob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `TowniVerse-${Date.now()}.zip`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }

      async function importFromZipUrl(zipUrl) {
        if (!window.JSZip) throw new Error("JSZip을 불러오지 못했습니다.");

        console.log('Fetching ZIP from:', zipUrl);

        // Fetch the ZIP file
        const response = await fetch(zipUrl);
        if (!response.ok) {
          throw new Error(`ZIP 파일을 불러올 수 없습니다 (${response.status})`);
        }

        const zipBlob = await response.blob();
        const zip = await JSZip.loadAsync(zipBlob);

        // Read manifest.json
        const manifestFile = zip.file('manifest.json');
        if (!manifestFile) {
          throw new Error('ZIP 파일에 manifest.json이 없습니다');
        }

        const manifestText = await manifestFile.async('text');
        const manifest = JSON.parse(manifestText);

        if (!manifest.tiles || !Array.isArray(manifest.tiles)) {
          throw new Error('잘못된 manifest 형식입니다');
        }

        // Get existing tiles to check for duplicates
        const existingTiles = await tileStore.getTiles();
        const existingLabels = new Set(existingTiles.map(t => t.label));

        // Import each tile
        let importedCount = 0;
        let skippedCount = 0;
        for (const tileEntry of manifest.tiles) {
          try {
            // Skip if already exists
            if (existingLabels.has(tileEntry.label)) {
              console.log(`타일 건너뛰기 (이미 존재함): ${tileEntry.label}`);
              skippedCount++;
              continue;
            }

            const imageFile = zip.file(tileEntry.file);
            if (!imageFile) {
              console.warn(`이미지 파일을 찾을 수 없습니다: ${tileEntry.file}`);
              continue;
            }

            const imageBlob = await imageFile.async('blob');
            const dataUrl = await blobToDataURL(imageBlob);

            // Add to IndexedDB
            await tileStore.addTile({
              label: tileEntry.label,
              originY: tileEntry.originY,
              dataUrl: dataUrl,
              displayScale: tileEntry.displayScale ?? 1,
              gridWidth: tileEntry.gridWidth ?? 1,
              gridHeight: tileEntry.gridHeight ?? 1,
            });

            importedCount++;
          } catch (error) {
            console.error(`타일 가져오기 실패 (${tileEntry.label}):`, error);
          }
        }

        console.log(`가져오기 완료: ${importedCount}개 추가, ${skippedCount}개 건너뜀`);

        if (importedCount === 0) {
          throw new Error('가져온 타일이 없습니다');
        }

        // Refresh the palette display and load textures
        await loadPaletteAndStart();
        await registerMissingTextures();
      }

      async function importFromUrl(baseUrl) {
        // Ensure baseUrl ends with /
        const normalizedUrl = baseUrl.endsWith('/') ? baseUrl : baseUrl + '/';

        // Fetch manifest.json
        const manifestUrl = normalizedUrl + 'manifest.json';
        console.log('Fetching manifest from:', manifestUrl);

        let manifestResponse;
        try {
          manifestResponse = await fetch(manifestUrl);
        } catch (error) {
          throw new Error(`네트워크 오류: ${error.message}\n\nCORS 설정을 확인하거나 로컬 서버를 사용하세요.`);
        }

        if (!manifestResponse.ok) {
          throw new Error(`manifest.json을 찾을 수 없습니다 (${manifestResponse.status})\n\nURL: ${manifestUrl}\n\n확인사항:\n- URL이 정확한가요?\n- manifest.json 파일이 해당 위치에 있나요?\n- 서버의 CORS 설정이 되어있나요?`);
        }

        const manifest = await manifestResponse.json();
        if (!manifest.tiles || !Array.isArray(manifest.tiles)) {
          throw new Error('잘못된 manifest 형식입니다');
        }

        // Get existing tiles to check for duplicates
        const existingTiles = await tileStore.getTiles();
        const existingLabels = new Set(existingTiles.map(t => t.label));

        // Import each tile
        let importedCount = 0;
        let skippedCount = 0;
        for (const tileEntry of manifest.tiles) {
          try {
            // Skip if already exists
            if (existingLabels.has(tileEntry.label)) {
              console.log(`타일 건너뛰기 (이미 존재함): ${tileEntry.label}`);
              skippedCount++;
              continue;
            }

            const imageUrl = normalizedUrl + tileEntry.file;
            const imageResponse = await fetch(imageUrl);
            if (!imageResponse.ok) {
              console.warn(`이미지를 불러올 수 없습니다: ${imageUrl}`);
              continue;
            }

            const blob = await imageResponse.blob();
            const dataUrl = await blobToDataURL(blob);

            // Add to IndexedDB
            await tileStore.addTile({
              label: tileEntry.label,
              originY: tileEntry.originY,
              dataUrl: dataUrl,
              displayScale: tileEntry.displayScale ?? 1,
              gridWidth: tileEntry.gridWidth ?? 1,
              gridHeight: tileEntry.gridHeight ?? 1,
            });

            importedCount++;
          } catch (error) {
            console.error(`타일 가져오기 실패 (${tileEntry.label}):`, error);
          }
        }

        console.log(`가져오기 완료: ${importedCount}개 추가, ${skippedCount}개 건너뜀`);

        if (importedCount === 0) {
          throw new Error('가져온 타일이 없습니다');
        }

        // Refresh the palette display and load textures
        await loadPaletteAndStart();
        await registerMissingTextures();
      }

      async function getTileBlob(tile) {
        if (tile.isCustom && tile.dataUrl) {
          return dataURLToBlob(tile.dataUrl);
        }
        const response = await fetch(tile.runtimeUrl || tile.url);
        if (!response.ok) throw new Error(`파일을 읽을 수 없습니다: ${tile.url}`);
        return await response.blob();
      }

      function blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(reader.error);
          reader.readAsDataURL(blob);
        });
      }

      async function resizePngBlob(file, targetWidth) {
        const bitmap = await createImageBitmap(file);
        const ratio = targetWidth / bitmap.width;
        const targetHeight = Math.max(1, Math.round(bitmap.height * ratio));
        const canvas = document.createElement("canvas");
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(bitmap, 0, 0, targetWidth, targetHeight);
        bitmap.close();
        return await new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (blob) resolve(blob);
            else reject(new Error("리사이즈 실패"));
          }, "image/png");
        });
      }

      function blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

      function dataURLToBlob(dataUrl) {
        const [meta, content] = dataUrl.split(",");
        const mime = meta.match(/:(.*?);/)?.[1] || "image/png";
        const binary = atob(content);
        const array = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          array[i] = binary.charCodeAt(i);
        }
        return new Blob([array], { type: mime });
      }

      async function registerMissingTextures() {
        if (!game) return;
        const promises = [];
        palette.forEach((tile) => {
          if (game.textures.exists(tile.key)) {
            tile.loaded = true;
            console.log("Texture already exists:", tile.key);
            return;
          }
          if (tile.isCustom && tile.dataUrl) {
            console.log("Loading custom texture:", tile.key);
            promises.push(
              new Promise((resolve, reject) => {
                try {
                  game.textures.once('addtexture', (key) => {
                    if (key === tile.key) {
                      tile.loaded = true;
                      console.log("Custom texture loaded:", tile.key);
                      resolve();
                    }
                  });
                  game.textures.addBase64(tile.key, tile.dataUrl);
                  // Fallback: resolve after timeout
                  setTimeout(() => {
                    if (!tile.loaded) {
                      tile.loaded = game.textures.exists(tile.key);
                      console.log("Texture load timeout, forced check:", tile.key, tile.loaded);
                      resolve();
                    }
                  }, 1000);
                } catch (error) {
                  console.error("Error loading texture:", tile.key, error);
                  reject(error);
                }
              })
            );
          } else if (tile.runtimeUrl || tile.url) {
            const source = tile.runtimeUrl || tile.url;
            promises.push(
              fetchAsDataURL(source).then((dataUrl) => {
                return new Promise((resolve, reject) => {
                  try {
                    game.textures.once('addtexture', (key) => {
                      if (key === tile.key) {
                        tile.loaded = true;
                        resolve();
                      }
                    });
                    game.textures.addBase64(tile.key, dataUrl);
                    setTimeout(() => {
                      if (!tile.loaded) {
                        tile.loaded = game.textures.exists(tile.key);
                        resolve();
                      }
                    }, 1000);
                  } catch (error) {
                    console.error("Error loading texture:", tile.key, error);
                    reject(error);
                  }
                });
              })
            );
          }
        });
        await Promise.all(promises);
        console.log("All textures registered");
      }

      async function fetchAsDataURL(url) {
        const response = await fetch(url);
        if (!response.ok) throw new Error("텍스처를 불러오지 못했습니다: " + url);
        const blob = await response.blob();
        return await blobToDataURL(blob);
      }

      function createCalibrator() {
        const modal = document.getElementById("calibration-modal");
        const canvas = document.getElementById("calibration-canvas");
        const hint = document.getElementById("calibration-hint");
        const confirmBtn = document.getElementById("calibration-confirm");
        const skipBtn = document.getElementById("calibration-skip");
        const resetBtn = document.getElementById("calibration-reset");
        const ctx = canvas.getContext("2d");
        const ORDER = ["하단", "왼쪽", "오른쪽", "상단"];

        let resolveFn = null;
        let image = null;
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let points = [];
        let currentGridWidth = 1;
        let currentGridHeight = 1;

        canvas.addEventListener("click", (event) => {
          if (!image || points.length >= 4) return;
          const rect = canvas.getBoundingClientRect();
          const ratioX = canvas.width / rect.width;
          const ratioY = canvas.height / rect.height;
          const canvasX = (event.clientX - rect.left) * ratioX;
          const canvasY = (event.clientY - rect.top) * ratioY;
          const imgX = (canvasX - offsetX) / scale;
          const imgY = (canvasY - offsetY) / scale;
          points.push({
            x: Math.max(0, Math.min(image.width, imgX)),
            y: Math.max(0, Math.min(image.height, imgY)),
            canvasX,
            canvasY,
          });
          drawOverlay();
          updateHint();
        });

        resetBtn.addEventListener("click", () => {
          points = [];
          drawOverlay();
          updateHint();
        });

        skipBtn.addEventListener("click", () => {
          close(null);
        });

        confirmBtn.addEventListener("click", async () => {
          if (!image || points.length < 4) return;
          try {
            // 새로운 순서: 하단(0), 왼쪽(1), 오른쪽(2), 상단(3)
            const ordered = {
              top: points[3],
              right: points[2],
              bottom: points[0],
              left: points[1],
            };

            // 격자 크기에 따라 마름모 크기 조정
            // 1x1: 256x128 다이아몬드
            // 2x1: 가로로 2개 격자 = 가로 방향으로 TILE_WIDTH만큼 더 넓음
            // 1x2: 세로로 2개 격자 = 세로 방향으로 TILE_HEIGHT만큼 더 넓음
            // 2x2: 양쪽 모두 확장

            // 다중 격자 타일의 실제 다이아몬드 크기 계산
            // gridWidth=2, gridHeight=1 인 경우:
            //   - 가로 범위: col 0~1 을 차지
            //   - 실제 다이아몬드 너비: TILE_WIDTH * gridWidth
            const diamondWidth = TILE_WIDTH * currentGridWidth;
            const diamondHeight = TILE_HEIGHT * currentGridHeight;

            // 출력 캔버스 크기 (여유 공간 포함)
            const outputWidth = diamondWidth * 2;
            const outputHeight = TILE_HEIGHT * 4;  // 높이는 건물이 높을 수 있으니 여유있게

            // 마름모를 캔버스 하단 중앙에 배치
            const centerX = outputWidth / 2;
            const baseY = outputHeight - TILE_HEIGHT;  // 하단에서 한 타일 높이만큼 위

            // 목표: 격자 크기에 맞는 마름모를 하단 중앙에 배치
            const dstTop = { x: centerX, y: baseY - diamondHeight / 2 };
            const dstRight = { x: centerX + diamondWidth / 2, y: baseY };
            const dstBottom = { x: centerX, y: baseY + diamondHeight / 2 };
            const dstLeft = { x: centerX - diamondWidth / 2, y: baseY };

            const warpedBlob = await warpImageWithPerspective(
              image,
              [ordered.top, ordered.right, ordered.bottom, ordered.left],
              [dstTop, dstRight, dstBottom, dstLeft],
              outputWidth,
              outputHeight
            );

            // 여백 제거 - 하지만 마름모 하단을 기준점으로 유지
            status.textContent = "여백 제거 중...";
            const trimmedBlob = await trimTransparentEdgesWithBase(warpedBlob, baseY + diamondHeight / 2);

            close({ blob: trimmedBlob });
          } catch (error) {
            console.error("calibration error", error);
            close(null);
          }
        });

        function updateHint() {
          if (!hint) return;
          if (points.length < 4) {
            hint.textContent = `${ORDER[points.length]} 꼭짓점을 클릭하세요.`;
            confirmBtn.disabled = true;
          } else {
            hint.textContent = "확인 버튼을 눌러 보정을 완료하세요.";
            confirmBtn.disabled = false;
          }
        }

        function drawOverlay() {
          if (!image) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
          }
          const scaleX = canvas.width / image.width;
          const scaleY = canvas.height / image.height;
          scale = Math.min(scaleX, scaleY);
          offsetX = (canvas.width - image.width * scale) / 2;
          offsetY = (canvas.height - image.height * scale) / 2;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();
          ctx.translate(offsetX, offsetY);
          ctx.scale(scale, scale);
          ctx.drawImage(image, 0, 0);
          ctx.restore();

          // 상단 점 가이드 표시 (하단, 왼쪽, 오른쪽을 모두 찍은 경우)
          if (points.length === 3) {
            // points[0] = 하단, points[1] = 왼쪽, points[2] = 오른쪽
            const bottom = points[0];
            const left = points[1];
            const right = points[2];

            // 좌우 중심점 계산
            const centerX = (left.canvasX + right.canvasX) / 2;
            const centerY = (left.canvasY + right.canvasY) / 2;

            // 하단에서 중심까지의 벡터
            const dx = centerX - bottom.canvasX;
            const dy = centerY - bottom.canvasY;

            // 상단 점은 중심에서 같은 거리만큼 반대 방향
            const topX = centerX + dx;
            const topY = centerY + dy;

            // 가이드 십자선 그리기
            ctx.save();
            ctx.strokeStyle = "rgba(0, 255, 0, 0.7)";
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            // 수평선
            ctx.beginPath();
            ctx.moveTo(topX - 20, topY);
            ctx.lineTo(topX + 20, topY);
            ctx.stroke();

            // 수직선
            ctx.beginPath();
            ctx.moveTo(topX, topY - 20);
            ctx.lineTo(topX, topY + 20);
            ctx.stroke();

            // 중심 점
            ctx.fillStyle = "rgba(0, 255, 0, 0.7)";
            ctx.beginPath();
            ctx.arc(topX, topY, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
          }

          // 사용자가 클릭한 점들 표시
          ctx.fillStyle = "#ffbd4a";
          ctx.strokeStyle = "#ffbd4a";
          ctx.lineWidth = 2;
          ctx.setLineDash([]); // 점선 해제
          if (points.length) {
            ctx.beginPath();
            points.forEach((p, index) => {
              const x = p.canvasX;
              const y = p.canvasY;
              if (index === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            });
            ctx.stroke();
          }
          points.forEach((p) => {
            ctx.beginPath();
            ctx.arc(p.canvasX, p.canvasY, 5, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        function close(result) {
          modal.classList.remove("visible");
          image = null;
          points = [];
          confirmBtn.disabled = true;
          if (resolveFn) {
            resolveFn(result || null);
            resolveFn = null;
          }
        }

        function syncCanvasSize() {
          const rect = canvas.getBoundingClientRect();
          canvas.width = rect.width;
          canvas.height = rect.height;
        }

        return {
          async open(file, gridWidth = 1, gridHeight = 1) {
            currentGridWidth = gridWidth;
            currentGridHeight = gridHeight;
            const dataUrl = await blobToDataURL(file);
            image = await loadImageElement(dataUrl);
            points = [];
            syncCanvasSize();
            drawOverlay();
            updateHint();
            modal.classList.add("visible");
            return new Promise((resolve) => {
              resolveFn = resolve;
            });
          },
        };
      }

      function computePerspectiveTransform(srcPts, dstPts) {
        // 4점 perspective transform 계산 (homography)
        // 8개 방정식 (x,y 각 4쌍)으로 8개 미지수 해결
        const matrix = [];
        const vector = [];

        for (let i = 0; i < 4; i++) {
          const { x, y } = srcPts[i];
          const { x: X, y: Y } = dstPts[i];

          // X 방정식: X = (ax + by + c) / (gx + hy + 1)
          // -> ax + by + c - gxX - hyX - X = 0
          matrix.push([x, y, 1, 0, 0, 0, -x*X, -y*X]);
          vector.push(X);

          // Y 방정식: Y = (dx + ey + f) / (gx + hy + 1)
          // -> dx + ey + f - gxY - hyY - Y = 0
          matrix.push([0, 0, 0, x, y, 1, -x*Y, -y*Y]);
          vector.push(Y);
        }

        const solution = solveLinearSystem(matrix, vector);
        return {
          a: solution[0], b: solution[1], c: solution[2],
          d: solution[3], e: solution[4], f: solution[5],
          g: solution[6], h: solution[7]
        };
      }

      function solveLinearSystem(matrix, vector) {
        const size = matrix.length;
        const numVars = matrix[0].length;
        const M = matrix.map((row, i) => [...row, vector[i]]);

        // Gaussian elimination with partial pivoting
        for (let col = 0; col < numVars; col++) {
          let pivot = col;
          for (let row = col + 1; row < size; row++) {
            if (Math.abs(M[row][col]) > Math.abs(M[pivot][col])) {
              pivot = row;
            }
          }
          const temp = M[col];
          M[col] = M[pivot];
          M[pivot] = temp;
          const pivotVal = M[col][col] || 1e-10;
          for (let j = col; j <= numVars; j++) {
            M[col][j] /= pivotVal;
          }
          for (let row = 0; row < size; row++) {
            if (row === col) continue;
            const factor = M[row][col];
            for (let j = col; j <= numVars; j++) {
              M[row][j] -= factor * M[col][j];
            }
          }
        }
        return M.map((row) => row[numVars]);
      }

      async function warpImageWithPerspective(image, srcPts, dstPts, outputWidth, outputHeight) {
        // perspective transform 계산
        const H = computePerspectiveTransform(srcPts, dstPts);

        // 역변환 행렬 계산 (destination -> source mapping)
        const invH = computePerspectiveTransform(dstPts, srcPts);

        const canvas = document.createElement("canvas");
        canvas.width = outputWidth;
        canvas.height = outputHeight;
        const ctx = canvas.getContext("2d");

        // 임시 캔버스에 원본 이미지 그리기
        const srcCanvas = document.createElement("canvas");
        srcCanvas.width = image.width;
        srcCanvas.height = image.height;
        const srcCtx = srcCanvas.getContext("2d");
        srcCtx.drawImage(image, 0, 0);
        const srcData = srcCtx.getImageData(0, 0, image.width, image.height);
        const srcPixels = srcData.data;

        // 출력 이미지 데이터
        const dstData = ctx.createImageData(outputWidth, outputHeight);
        const dstPixels = dstData.data;

        // 역방향 매핑으로 각 픽셀 변환
        for (let dstY = 0; dstY < outputHeight; dstY++) {
          for (let dstX = 0; dstX < outputWidth; dstX++) {
            // destination 좌표를 source 좌표로 변환
            const src = applyPerspectiveTransform(invH, dstX, dstY);
            const srcX = Math.round(src.x);
            const srcY = Math.round(src.y);

            // 범위 체크
            if (srcX >= 0 && srcX < image.width && srcY >= 0 && srcY < image.height) {
              const srcIdx = (srcY * image.width + srcX) * 4;
              const dstIdx = (dstY * outputWidth + dstX) * 4;
              dstPixels[dstIdx] = srcPixels[srcIdx];         // R
              dstPixels[dstIdx + 1] = srcPixels[srcIdx + 1]; // G
              dstPixels[dstIdx + 2] = srcPixels[srcIdx + 2]; // B
              dstPixels[dstIdx + 3] = srcPixels[srcIdx + 3]; // A
            }
          }
        }

        ctx.putImageData(dstData, 0, 0);

        return await new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (blob) resolve(blob);
            else reject(new Error("perspective warp failed"));
          }, "image/png");
        });
      }

      function applyPerspectiveTransform(H, x, y) {
        const w = H.g * x + H.h * y + 1;
        return {
          x: (H.a * x + H.b * y + H.c) / w,
          y: (H.d * x + H.e * y + H.f) / w,
        };
      }

      function distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
      }

      async function trimTransparentEdgesWithBase(blob, baseY) {
        const img = await loadImageElement(await blobToDataURL(blob));
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        let minX = canvas.width;
        let minY = canvas.height;
        let maxX = 0;
        let maxY = 0;

        // 투명하지 않은 픽셀의 경계 찾기
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const alpha = pixels[(y * canvas.width + x) * 4 + 3];
            if (alpha > 0) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          }
        }

        // 여백이 없는 경우 원본 반환
        if (minX > maxX || minY > maxY) {
          return blob;
        }

        // 크롭: 좌우는 콘텐츠 기준, 상단은 콘텐츠 기준, 하단은 baseY 기준
        const cropX = minX;
        const cropY = minY;
        const cropWidth = maxX - minX + 1;
        const cropHeight = Math.ceil(baseY) - minY + 1;  // baseY까지 포함

        const croppedCanvas = document.createElement("canvas");
        croppedCanvas.width = cropWidth;
        croppedCanvas.height = cropHeight;
        const croppedCtx = croppedCanvas.getContext("2d");
        croppedCtx.drawImage(canvas, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

        return await new Promise((resolve, reject) => {
          croppedCanvas.toBlob((blob) => {
            if (blob) resolve(blob);
            else reject(new Error("trim failed"));
          }, "image/png");
        });
      }

      function loadImageElement(dataUrl) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = dataUrl;
        });
      }

      function createTileStore() {
        const DB_NAME = "TowniVerseLocal";
        const STORE = "tiles";
        const PLACEMENTS_STORE = "placements";
        const dbPromise = new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, 2);  // 버전 2로 업그레이드
          request.onupgradeneeded = (event) => {
            const db = request.result;
            if (!db.objectStoreNames.contains(STORE)) {
              db.createObjectStore(STORE, { keyPath: "id", autoIncrement: true });
            }
            if (!db.objectStoreNames.contains(PLACEMENTS_STORE)) {
              db.createObjectStore(PLACEMENTS_STORE, { keyPath: "key" });
            }
          };
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });

        async function tx(mode) {
          const db = await dbPromise;
          return db.transaction(STORE, mode).objectStore(STORE);
        }

        return {
          async getTiles() {
            const store = await tx("readonly");
            return await new Promise((resolve, reject) => {
              const request = store.getAll();
              request.onsuccess = () => {
                const tiles = request.result.map((entry) => ({
                  key: entry.key,
                  label: entry.label,
                  originY: entry.originY,
                  displayScale: entry.displayScale ?? 1,
                  gridWidth: entry.gridWidth ?? 1,
                  gridHeight: entry.gridHeight ?? 1,
                  dataUrl: entry.dataUrl,
                  isCustom: true,
                }));
                resolve(tiles);
              };
              request.onerror = () => reject(request.error);
            });
          },
          async addTile({ label, originY, dataUrl, displayScale = 1, gridWidth = 1, gridHeight = 1 }) {
            const key = `custom-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`;
            const entry = {
              key,
              label,
              originY,
              dataUrl,
              displayScale,
              gridWidth,
              gridHeight,
              createdAt: Date.now(),
            };
            const store = await tx("readwrite");
            await new Promise((resolve, reject) => {
              const request = store.add(entry);
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
            return { ...entry, dataUrl: entry.dataUrl, displayScale, gridWidth, gridHeight, isCustom: true };
          },
          async deleteTile(key) {
            const store = await tx("readwrite");
            await new Promise((resolve, reject) => {
              const request = store.openCursor();
              request.onsuccess = () => {
                const cursor = request.result;
                if (!cursor) return resolve();
                if (cursor.value.key === key) {
                  cursor.delete();
                  resolve();
                } else {
                  cursor.continue();
                }
              };
              request.onerror = () => reject(request.error);
            });
          },
          async savePlacement(key, tileKey, col, row) {
            const db = await dbPromise;
            const store = db.transaction(PLACEMENTS_STORE, "readwrite").objectStore(PLACEMENTS_STORE);
            await new Promise((resolve, reject) => {
              const request = store.put({ key, tileKey, col, row });
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
          },
          async deletePlacement(key) {
            const db = await dbPromise;
            const store = db.transaction(PLACEMENTS_STORE, "readwrite").objectStore(PLACEMENTS_STORE);
            await new Promise((resolve, reject) => {
              const request = store.delete(key);
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
          },
          async getPlacements() {
            const db = await dbPromise;
            const store = db.transaction(PLACEMENTS_STORE, "readonly").objectStore(PLACEMENTS_STORE);
            return await new Promise((resolve, reject) => {
              const request = store.getAll();
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
            });
          },
          async clearAll() {
            const db = await dbPromise;
            // Clear tiles
            const tilesTx = db.transaction(STORE, "readwrite");
            await new Promise((resolve, reject) => {
              const request = tilesTx.objectStore(STORE).clear();
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
            // Clear placements
            const placementsTx = db.transaction(PLACEMENTS_STORE, "readwrite");
            await new Promise((resolve, reject) => {
              const request = placementsTx.objectStore(PLACEMENTS_STORE).clear();
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
          },
        };
      }
    </script>
  </body>
</html>
