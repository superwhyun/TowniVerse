<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: scene.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: scene.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { TILE_WIDTH, TILE_HEIGHT, WORLD_BOUNDS, GRID_BUFFER } from "./constants.js";
import { state, getState, setState } from "./state.js";
import { tileStore } from "./store.js";
import {
  diamondPoints,
  gridToScreen,
  screenToGrid,
  getPlacementBase,
  getVisibleBounds,
  isWithinBounds
} from "./grid.js";

/**
 * Loads saved placements from the store and restores them to the state.
 * @async
 * @returns {Promise&lt;void>}
 */
export async function loadSavedPlacements() {
  try {
    const placements = await tileStore.getPlacements();
    const tileDefinitions = getState('tileDefinitions');
    const placedTiles = getState('placedTiles');

    const tileGroups = new Map();

    placements.forEach(({ key, tileKey, col, row }) => {
      if (!tileGroups.has(tileKey)) {
        tileGroups.set(tileKey, []);
      }
      tileGroups.get(tileKey).push({ key, col, row });
    });

    const processedCells = new Set();

    placements.forEach(({ key, tileKey, col, row }) => {
      if (processedCells.has(key)) return;

      const tileDef = tileDefinitions.get(tileKey);
      const gridWidth = tileDef?.gridWidth || 1;
      const gridHeight = tileDef?.gridHeight || 1;

      const connectedCells = [];
      for (let r = 0; r &lt; gridHeight; r++) {
        for (let c = 0; c &lt; gridWidth; c++) {
          const testKey = `${col + c}-${row + r}`;
          const testPlacement = placements.find(p => p.key === testKey &amp;&amp; p.tileKey === tileKey);
          if (testPlacement) {
            connectedCells.push(testPlacement);
          }
        }
      }

      if (connectedCells.length === gridWidth * gridHeight) {
        const baseCol = col;
        const baseRow = row;

        connectedCells.forEach(({ key: cellKey, col: cellCol, row: cellRow }) => {
          processedCells.add(cellKey);
          placedTiles.set(cellKey, {
            tileKey,
            grid: { col: cellCol, row: cellRow },
            isBase: cellCol === baseCol &amp;&amp; cellRow === baseRow,
            baseCol,
            baseRow,
            gridWidth,
            gridHeight,
          });
        });
      }
    });

    console.log(`Loaded ${placements.length} placements from storage`);

    const game = getState('game');
    if (game) {
      const activeScene = game.scene.getAt(0);
      if (activeScene) {
        refreshSceneView(activeScene);
      }
    }
  } catch (error) {
    console.error("Failed to load placements:", error);
  }
}

/**
 * Initializes and starts the Phaser game instance.
 * @returns {void}
 */
export function startGame() {
  const game = getState('game');
  if (game) {
    return;
  }

  const scene = {
    preload: preloadScene,
    create: createScene,
    update: updateScene,
  };

  const config = {
    type: Phaser.AUTO,
    parent: "game-wrapper",
    width: 1600,
    height: 900,
    backgroundColor: "rgba(0,0,0,0)",
    transparent: true,
    scene,
    pixelArt: true,
    scale: {
      parent: "game-wrapper",
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH,
      width: '100%',
      height: '100%',
    },
  };
  const newGame = new Phaser.Game(config);
  setState('game', newGame);
}

/**
 * Phaser scene preload method.
 * Loads tile assets.
 * @this {Phaser.Scene}
 */
export function preloadScene() {
  const palette = getState('palette');
  palette.forEach((tile) => {
    const textureScale = tile.textureScale ?? tile.scale ?? 1;
    const assetUrl = tile.runtimeUrl;
    if (tile.isSvg &amp;&amp; this.load.svg) {
      this.load.svg(tile.key, assetUrl, { scale: textureScale });
    } else {
      this.load.image(tile.key, assetUrl);
    }
  });
}

/**
 * Phaser scene create method.
 * Sets up camera, inputs, and graphics.
 * @this {Phaser.Scene}
 */
export function createScene() {
  this.cameras.main.setBounds(
    -WORLD_BOUNDS,
    -WORLD_BOUNDS,
    WORLD_BOUNDS * 2,
    WORLD_BOUNDS * 2
  );
  this.cameras.main.setZoom(1);
  this.cameras.main.setBackgroundColor("rgba(0,0,0,0)");
  this.cameras.main.centerOn(0, 0);

  this.gridGraphics = this.add.graphics();
  this.gridGraphics.setDepth(-1000);
  this.previewGraphics = this.add.graphics();
  this.previewGraphics.setDepth(10000);

  const palette = getState('palette');
  palette.forEach((tile) => {
    if (this.textures.exists(tile.key)) {
      tile.loaded = true;
    }
  });

  let resizeDebounceTimer = null;
  this.scale.on("resize", () => {
    if (resizeDebounceTimer) {
      clearTimeout(resizeDebounceTimer);
    }
    resizeDebounceTimer = setTimeout(() => {
      refreshSceneView(this);
      updateDepths(this.cameras.main);
      resizeDebounceTimer = null;
    }, 100);
  });

  this.cursors = this.input.keyboard.createCursorKeys();

  this.input.on("wheel", (pointer, gameObjects, deltaX, deltaY, deltaZ, event) => {
    const cam = this.cameras.main;
    const zoomAmount = deltaY > 0 ? -0.02 : 0.02;
    const newZoom = Phaser.Math.Clamp(cam.zoom + zoomAmount, 0.3, 3);
    cam.setZoom(newZoom);
    refreshSceneView(this);
    updateDepths(cam);
    event?.preventDefault();
  });

  this.isDragging = false;
  this.dragStartX = 0;
  this.dragStartY = 0;

  this.input.on("pointerdown", (pointer) => {
    if (pointer.leftButtonDown()) {
      this.isDragging = true;
      this.dragStartX = pointer.x;
      this.dragStartY = pointer.y;
    }
  });

  this.input.on("pointerup", (pointer) => {
    this.isDragging = false;
  });

  this.input.on("pointermove", (pointer) => {
    if (this.isDragging) {
      const cam = this.cameras.main;
      const deltaX = (pointer.x - this.dragStartX) / cam.zoom;
      const deltaY = (pointer.y - this.dragStartY) / cam.zoom;
      cam.scrollX -= deltaX;
      cam.scrollY -= deltaY;
      this.dragStartX = pointer.x;
      this.dragStartY = pointer.y;
      refreshSceneView(this);
      updateDepths(cam);
      return;
    }

    const activeTileKey = getState('activeTileKey');
    if (!activeTileKey) {
      this.previewGraphics.clear();
      return;
    }
    const worldPoint = pointer.positionToCamera(this.cameras.main);
    const gridPoint = screenToGrid(worldPoint.x, worldPoint.y);
    if (!gridPoint) {
      this.previewGraphics.clear();
      return;
    }

    const tileDefinitions = getState('tileDefinitions');
    const tileDef = tileDefinitions.get(activeTileKey);
    if (!tileDef) return;

    const gridWidth = tileDef.gridWidth || 1;
    const gridHeight = tileDef.gridHeight || 1;
    const { baseCol, baseRow } = getPlacementBase(
      gridPoint.col,
      gridPoint.row,
      gridWidth,
      gridHeight
    );

    this.previewGraphics.clear();
    this.previewGraphics.lineStyle(3, 0xff0000, 0.8);

    for (let r = 0; r &lt; gridHeight; r++) {
      for (let c = 0; c &lt; gridWidth; c++) {
        const pos = gridToScreen(baseCol + c, baseRow + r);
        const diamond = [
          { x: pos.x, y: pos.y - TILE_HEIGHT / 2 },
          { x: pos.x + TILE_WIDTH / 2, y: pos.y },
          { x: pos.x, y: pos.y + TILE_HEIGHT / 2 },
          { x: pos.x - TILE_WIDTH / 2, y: pos.y },
        ];
        this.previewGraphics.beginPath();
        this.previewGraphics.moveTo(diamond[0].x, diamond[0].y);
        for (let i = 1; i &lt; diamond.length; i++) {
          this.previewGraphics.lineTo(diamond[i].x, diamond[i].y);
        }
        this.previewGraphics.closePath();
        this.previewGraphics.strokePath();
      }
    }
  });

  this.clickStartTime = 0;
  this.clickStartPos = { x: 0, y: 0 };

  this.input.on("pointerdown", async (pointer) => {
    if (pointer.leftButtonDown()) {
      this.clickStartTime = Date.now();
      this.clickStartPos = { x: pointer.x, y: pointer.y };
    }
  });

  this.input.on("pointerup", async (pointer) => {
    const worldPoint = pointer.positionToCamera(this.cameras.main);
    const gridPoint = screenToGrid(worldPoint.x, worldPoint.y);

    if (pointer.leftButtonReleased()) {
      const clickDuration = Date.now() - this.clickStartTime;
      const distance = Phaser.Math.Distance.Between(
        this.clickStartPos.x, this.clickStartPos.y,
        pointer.x, pointer.y
      );

      if (clickDuration &lt; 200 &amp;&amp; distance &lt; 5 &amp;&amp; gridPoint) {
        const activeTileKey = getState('activeTileKey');
        if (!activeTileKey) return;

        const tileDefinitions = getState('tileDefinitions');
        const tileDef = tileDefinitions.get(activeTileKey);
        if (!tileDef) return;

        const gridWidth = tileDef.gridWidth || 1;
        const gridHeight = tileDef.gridHeight || 1;
        const { baseCol, baseRow } = getPlacementBase(
          gridPoint.col,
          gridPoint.row,
          gridWidth,
          gridHeight
        );
        const baseKey = `${baseCol}-${baseRow}`;

        const placedTiles = getState('placedTiles');
        const spriteCache = getState('spriteCache');
        const existing = placedTiles.get(baseKey);

        if (existing &amp;&amp; existing.tileKey === activeTileKey &amp;&amp; existing.isBase) {
          const gw = existing.gridWidth || 1;
          const gh = existing.gridHeight || 1;
          for (let r = 0; r &lt; gh; r++) {
            for (let c = 0; c &lt; gw; c++) {
              const key = `${baseCol + c}-${baseRow + r}`;
              placedTiles.delete(key);
              await tileStore.deletePlacement(key);
            }
          }
          const sprite = spriteCache.get(baseKey);
          if (sprite) {
            sprite.destroy();
            spriteCache.delete(baseKey);
          }
          refreshSceneView(this);
          return;
        }

        for (let r = 0; r &lt; gridHeight; r++) {
          for (let c = 0; c &lt; gridWidth; c++) {
            const key = `${baseCol + c}-${baseRow + r}`;
            if (placedTiles.has(key)) {
              console.log("충돌: 이미 타일이 배치되어 있습니다.");
              return;
            }
          }
        }

        // 일괄 저장을 위한 배열
        const placementsToSave = [];

        for (let r = 0; r &lt; gridHeight; r++) {
          for (let c = 0; c &lt; gridWidth; c++) {
            const key = `${baseCol + c}-${baseRow + r}`;
            placedTiles.set(key, {
              tileKey: activeTileKey,
              grid: { col: baseCol + c, row: baseRow + r },
              isBase: r === 0 &amp;&amp; c === 0,
              baseCol,
              baseRow,
              gridWidth,
              gridHeight,
            });
            placementsToSave.push({
              key,
              tileKey: activeTileKey,
              col: baseCol + c,
              row: baseRow + r
            });
          }
        }

        // 트랜잭션 최적화: 한 번에 저장
        await tileStore.savePlacements(placementsToSave);

        refreshSceneView(this);
      }
    }

    if (pointer.rightButtonReleased() &amp;&amp; gridPoint) {
      const clickedKey = `${gridPoint.col}-${gridPoint.row}`;
      const placedTiles = getState('placedTiles');
      const clickedTile = placedTiles.get(clickedKey);

      if (clickedTile) {
        const baseKey = `${clickedTile.baseCol}-${clickedTile.baseRow}`;
        const baseTile = placedTiles.get(baseKey);

        if (baseTile) {
          const gw = baseTile.gridWidth || 1;
          const gh = baseTile.gridHeight || 1;
          const spriteCache = getState('spriteCache');

          // 일괄 삭제를 위한 키 배열
          const keysToDelete = [];

          for (let r = 0; r &lt; gh; r++) {
            for (let c = 0; c &lt; gw; c++) {
              const key = `${clickedTile.baseCol + c}-${clickedTile.baseRow + r}`;
              placedTiles.delete(key);
              keysToDelete.push(key);
            }
          }

          // 트랜잭션 최적화: 한 번에 삭제
          await tileStore.deletePlacements(keysToDelete);

          const sprite = spriteCache.get(baseKey);
          if (sprite) {
            sprite.destroy();
            spriteCache.delete(baseKey);
          }

          refreshSceneView(this);
        }
      }
    }
  });

  this.input.mouse.disableContextMenu();

  refreshSceneView(this);
}

/**
 * Phaser scene update method.
 * Handles camera movement.
 * @this {Phaser.Scene}
 * @param {number} time - Current time
 * @param {number} delta - Delta time since last frame
 */
export function updateScene(_, delta) {
  if (!this.cursors) return;
  const cam = this.cameras.main;
  const speed = 0.25 * delta;
  let moved = false;

  if (this.cursors.left.isDown) {
    cam.scrollX -= speed;
    moved = true;
  } else if (this.cursors.right.isDown) {
    cam.scrollX += speed;
    moved = true;
  }

  if (this.cursors.up.isDown) {
    cam.scrollY -= speed;
    moved = true;
  } else if (this.cursors.down.isDown) {
    cam.scrollY += speed;
    moved = true;
  }

  if (moved) {
    refreshSceneView(this);
    updateDepths(cam);
  }
}

/**
 * Refreshes the scene view by updating the grid and visible tiles.
 * @param {Phaser.Scene} scene - The scene instance
 */
export function refreshSceneView(scene) {
  const bounds = getVisibleBounds(scene.cameras.main, GRID_BUFFER);
  drawWireGrid(scene, bounds);
  syncVisibleTiles(scene, bounds);
}

/**
 * Updates the depth of all visible sprites based on their Y position.
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera instance
 */
function updateDepths(camera) {
  const offset = camera.scrollY;
  const spriteCache = getState('spriteCache');
  // Only update depth if the camera has moved significantly or if it's a forced update
  // For now, we'll keep it simple but ensure we're not doing unnecessary calculations
  spriteCache.forEach((sprite) => {
    // Isometric depth sorting: y + height/2 usually works well, or just y.
    // Subtracting scrollY keeps the relative depth correct if we want them to stay consistent with UI,
    // but for world objects, depth usually depends on world Y.
    // In this engine, it seems depth = y - scrollY is used.
    sprite.setDepth(sprite.y - offset);
  });
}

// Simple object pool for sprites could be implemented here, 
// but Phaser's Group or just creating/destroying is often fine for &lt; 1000 objects.
// However, let's optimize the destroy/create cycle by checking if we can reuse.
// Actually, the current implementation destroys sprites that go out of bounds.
// To optimize, we could keep them in a 'dead' pool.

const spritePool = [];

function getSpriteFromPool(scene, x, y, key) {
  const poolItem = spritePool.find(s => s.texture.key === key &amp;&amp; !s.active);
  if (poolItem) {
    poolItem.setActive(true);
    poolItem.setVisible(true);
    poolItem.setPosition(x, y);
    return poolItem;
  }
  return scene.add.image(x, y, key);
}

function releaseSpriteToPool(sprite) {
  sprite.setActive(false);
  sprite.setVisible(false);
  // We don't destroy, just hide and keep in pool (if we were using a real pool)
  // But since we are using a Map for spriteCache, we need to be careful.
  // For this specific codebase, let's stick to destroy for simplicity unless we implement a full pool manager,
  // but we can optimize the loop.
  sprite.destroy();
}

/**
 * Syncs visible tiles with the current view bounds.
 * Creates new sprites for tiles entering the view and removes/pools sprites leaving the view.
 * @param {Phaser.Scene} scene - The scene instance
 * @param {{minCol: number, maxCol: number, minRow: number, maxRow: number}} bounds - Visible bounds
 */
function syncVisibleTiles(scene, bounds) {
  const spriteCache = getState('spriteCache');
  const placedTiles = getState('placedTiles');
  const tileDefinitions = getState('tileDefinitions');

  // 1. Remove sprites that are out of bounds
  for (const [key, sprite] of spriteCache) {
    const data = placedTiles.get(key);
    if (!data || !data.isBase || !isWithinBounds(data.grid, bounds)) {
      sprite.destroy(); // Or release to pool
      spriteCache.delete(key);
    }
  }

  // 2. Add sprites that are in bounds but not yet created
  // Iterate only through the bounds instead of all placed tiles if possible?
  // No, placedTiles is a Map, we can't easily query by bounds without a spatial index.
  // So iterating placedTiles is necessary, but we can optimize by checking bounds first.

  // Optimization: If placedTiles is very large, this loop is slow.
  // A spatial hash or quadtree would be better. 
  // For now, we'll stick to the loop but ensure fast fail.

  placedTiles.forEach((data, key) => {
    if (!data.isBase) return;

    // Fast bound check
    if (!isWithinBounds(data.grid, bounds)) return;

    // If already has sprite, skip
    if (spriteCache.has(key)) return;

    if (!tileDefinitions.get(data.tileKey)?.loaded) {
      return;
    }

    const tileDef = tileDefinitions.get(data.tileKey);
    if (!tileDef) return;

    const gridWidth = data.gridWidth || 1;
    const gridHeight = data.gridHeight || 1;
    const baseCol = data.baseCol ?? data.grid.col;
    const baseRow = data.baseRow ?? data.grid.row;

    const rowAdjustment = (gridWidth === 2 &amp;&amp; gridHeight === 2) ? 0.75 : 0;
    const colAdjustment = (gridWidth === 2 &amp;&amp; gridHeight === 2) ? -0.75 : 0;

    const bottomLeft = gridToScreen(baseCol, baseRow + gridHeight - 1 + rowAdjustment);
    const bottomRight = gridToScreen(
      baseCol + gridWidth - 1 + rowAdjustment,
      baseRow + gridHeight - 1 + colAdjustment
    );
    const world = {
      x: (bottomLeft.x + bottomRight.x) / 2,
      y: (bottomLeft.y + bottomRight.y) / 2,
    };

    const sprite = scene.add.image(world.x, world.y, data.tileKey);
    sprite.setOrigin(0.5, tileDef.originY ?? 0.5);
    const targetWidth = tileDef.fitWidth ?? TILE_WIDTH;
    const autoScale = sprite.width ? targetWidth / sprite.width : 1;
    const scale = tileDef.displayScale ?? autoScale;
    if (scale &amp;&amp; Math.abs(scale - 1) > 0.001) {
      sprite.setScale(scale);
    }
    spriteCache.set(key, sprite);
    sprite.setDepth(sprite.y - scene.cameras.main.scrollY);
  });
}

/**
 * Draws the wireframe grid for the visible area.
 * @param {Phaser.Scene} scene - The scene instance
 * @param {{minCol: number, maxCol: number, minRow: number, maxRow: number}} bounds - Visible bounds
 */
function drawWireGrid(scene, bounds) {
  if (!scene.gridGraphics) return;
  scene.gridGraphics.clear();

  const placedTiles = getState('placedTiles');

  for (let row = bounds.minRow; row &lt;= bounds.maxRow; row++) {
    for (let col = bounds.minCol; col &lt;= bounds.maxCol; col++) {
      const center = gridToScreen(col, row);
      const diamond = diamondPoints(center.x, center.y);

      const cellKey = `${col}-${row}`;
      const isPlaced = placedTiles.has(cellKey);

      if (isPlaced) {
        scene.gridGraphics.fillStyle(0xffffff, 0.15);
        scene.gridGraphics.fillPoints(diamond, true);
      }

      scene.gridGraphics.lineStyle(1.5, 0xffffff, 0.22);
      scene.gridGraphics.strokePoints(diamond, true);
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#Calibrator">Calibrator</a></li><li><a href="global.html#DB_NAME">DB_NAME</a></li><li><a href="global.html#GRID_BUFFER">GRID_BUFFER</a></li><li><a href="global.html#TILES_PER_PAGE">TILES_PER_PAGE</a></li><li><a href="global.html#TILE_HEIGHT">TILE_HEIGHT</a></li><li><a href="global.html#TILE_WIDTH">TILE_WIDTH</a></li><li><a href="global.html#WHEEL_SCROLL_FACTOR">WHEEL_SCROLL_FACTOR</a></li><li><a href="global.html#WORLD_BOUNDS">WORLD_BOUNDS</a></li><li><a href="global.html#addTile">addTile</a></li><li><a href="global.html#addTileWithKey">addTileWithKey</a></li><li><a href="global.html#blobToDataURL">blobToDataURL</a></li><li><a href="global.html#clearAll">clearAll</a></li><li><a href="global.html#createCalibrator">createCalibrator</a></li><li><a href="global.html#createScene">createScene</a></li><li><a href="global.html#createTileStore">createTileStore</a></li><li><a href="global.html#deleteCustomTile">deleteCustomTile</a></li><li><a href="global.html#deletePlacement">deletePlacement</a></li><li><a href="global.html#deletePlacements">deletePlacements</a></li><li><a href="global.html#deleteTile">deleteTile</a></li><li><a href="global.html#diamondPoints">diamondPoints</a></li><li><a href="global.html#diamondPointsScaled">diamondPointsScaled</a></li><li><a href="global.html#drawWireGrid">drawWireGrid</a></li><li><a href="global.html#filterAndRenderPalette">filterAndRenderPalette</a></li><li><a href="global.html#filterPalette">filterPalette</a></li><li><a href="global.html#getPlacementBase">getPlacementBase</a></li><li><a href="global.html#getPlacements">getPlacements</a></li><li><a href="global.html#getState">getState</a></li><li><a href="global.html#getTiles">getTiles</a></li><li><a href="global.html#getVisibleBounds">getVisibleBounds</a></li><li><a href="global.html#gridOrigin">gridOrigin</a></li><li><a href="global.html#gridToScreen">gridToScreen</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#isWithinBounds">isWithinBounds</a></li><li><a href="global.html#loadImageElement">loadImageElement</a></li><li><a href="global.html#loadSavedPlacements">loadSavedPlacements</a></li><li><a href="global.html#preloadScene">preloadScene</a></li><li><a href="global.html#refreshSceneView">refreshSceneView</a></li><li><a href="global.html#renderPalette">renderPalette</a></li><li><a href="global.html#savePlacement">savePlacement</a></li><li><a href="global.html#savePlacements">savePlacements</a></li><li><a href="global.html#screenToGrid">screenToGrid</a></li><li><a href="global.html#screenToGridFloat">screenToGridFloat</a></li><li><a href="global.html#setActiveTile">setActiveTile</a></li><li><a href="global.html#setState">setState</a></li><li><a href="global.html#setupGridSizeToggle">setupGridSizeToggle</a></li><li><a href="global.html#setupPalette">setupPalette</a></li><li><a href="global.html#setupSearch">setupSearch</a></li><li><a href="global.html#startGame">startGame</a></li><li><a href="global.html#syncVisibleTiles">syncVisibleTiles</a></li><li><a href="global.html#updateDepths">updateDepths</a></li><li><a href="global.html#updatePaginationButtons">updatePaginationButtons</a></li><li><a href="global.html#updateScene">updateScene</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Fri Nov 21 2025 23:40:45 GMT+0900 (Korean Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
