<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { state, getState, setState } from "./state.js";
import { TILES_PER_PAGE } from "./constants.js";

/**
 * Sets up the tile palette click event listener.
 */
export function setupPalette() {
  const paletteContainer = document.getElementById("tile-palette");
  if (!paletteContainer) return;

  paletteContainer.addEventListener("click", (event) => {
    const button = event.target.closest(".tile-swatch");
    if (!button) return;
    setActiveTile(button.dataset.tileKey);
  });
}

/**
 * Renders the tile palette UI based on the current state.
 */
export function renderPalette() {
  const paletteContainer = document.getElementById("tile-palette");
  if (!paletteContainer) return;

  paletteContainer.innerHTML = "";

  const filteredPalette = getState('filteredPalette');
  const currentPage = getState('currentPage');
  const activeTileKey = getState('activeTileKey');

  const start = currentPage * TILES_PER_PAGE;
  const end = start + TILES_PER_PAGE;
  const pageItems = filteredPalette.slice(start, end);

  if (pageItems.length === 0) {
    paletteContainer.textContent = getState('searchQuery') ? "검색 결과가 없습니다." : "등록된 타일이 없습니다.";
    return;
  }

  pageItems.forEach((tile) => {
    const div = document.createElement("div");
    div.className = `tile-item ${tile.key === activeTileKey ? "active" : ""}`;
    div.dataset.key = tile.key;

    // 미리보기 이미지
    const img = document.createElement("img");
    img.src = tile.previewUrl || tile.runtimeUrl;
    img.alt = tile.label;

    // 툴팁 (타일 이름)
    div.title = tile.label;

    div.appendChild(img);

    // 클릭 시 활성화
    div.addEventListener("click", () => {
      setActiveTile(tile.key);
    });

    // 우클릭 시 삭제 (커스텀 타일만)
    if (tile.isCustom) {
      div.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        if (confirm(`"${tile.label}" 타일을 삭제하시겠습니까?`)) {
          deleteCustomTile(tile.key);
        }
      });
    }

    paletteContainer.appendChild(div);
  });

  updatePaginationButtons();
}

/**
 * Sets the active tile for placement.
 * @param {string} key - The key of the tile to activate
 */
export function setActiveTile(key) {
  setState('activeTileKey', key);

  // UI 업데이트
  const items = document.querySelectorAll(".tile-item");
  items.forEach((item) => {
    if (item.dataset.key === key) {
      item.classList.add("active");
    } else {
      item.classList.remove("active");
    }
  });
}

/**
 * Deletes a custom tile from the store and state.
 * @param {string} key - The key of the tile to delete
 */
async function deleteCustomTile(key) {
  const { tileStore } = await import("./store.js"); // 순환 참조 방지

  await tileStore.deleteTile(key);

  // 상태 업데이트
  const palette = getState('palette').filter(t => t.key !== key);
  setState('palette', palette);

  const tileDefinitions = getState('tileDefinitions');
  tileDefinitions.delete(key);

  // 필터링 다시 적용
  filterPalette();

  // 만약 삭제된 타일이 활성화 상태였다면 해제
  if (getState('activeTileKey') === key) {
    setState('activeTileKey', null);
  }
}

/**
 * Updates the state of pagination buttons.
 */
export function updatePaginationButtons() {
  const prevBtn = document.getElementById("prev-page");
  const nextBtn = document.getElementById("next-page");
  const pageInfo = document.getElementById("page-info");

  if (!prevBtn || !nextBtn || !pageInfo) return;

  const filteredPalette = getState('filteredPalette');
  const currentPage = getState('currentPage');
  const totalPages = Math.ceil(filteredPalette.length / TILES_PER_PAGE) || 1;

  pageInfo.textContent = `${currentPage + 1} / ${totalPages}`;
  prevBtn.disabled = currentPage === 0;
  nextBtn.disabled = currentPage >= totalPages - 1;

  prevBtn.onclick = () => {
    if (currentPage > 0) {
      setState('currentPage', currentPage - 1);
      renderPalette();
    }
  };

  nextBtn.onclick = () => {
    if (currentPage &lt; totalPages - 1) {
      setState('currentPage', currentPage + 1);
      renderPalette();
    }
  };
}

/**
 * Filters the palette based on the search query.
 */
export function filterPalette() {
  const query = getState('searchQuery').toLowerCase();
  const palette = getState('palette');

  const filtered = palette.filter(t =>
    t.label.toLowerCase().includes(query)
  );

  setState('filteredPalette', filtered);
  setState('currentPage', 0);
  renderPalette();
}

/**
 * Filters the palette and renders it (used by tile-manager).
 */
export function filterAndRenderPalette() {
  const searchQuery = getState('searchQuery');
  const palette = getState('palette');

  let filteredPalette;
  if (searchQuery) {
    filteredPalette = palette.filter(tile =>
      tile.label.toLowerCase().includes(searchQuery) ||
      tile.key.toLowerCase().includes(searchQuery)
    );
  } else {
    filteredPalette = [...palette];
  }
  setState('filteredPalette', filteredPalette);

  renderPalette();
  updatePaginationButtons();
}

/**
 * Sets up the search input event listener.
 */
export function setupSearch() {
  const searchInput = document.getElementById("search-input");
  if (!searchInput) return;

  searchInput.addEventListener("input", (e) => {
    setState('searchQuery', e.target.value);
    filterPalette();
  });
}

/**
 * Sets up the grid size toggle buttons.
 */
export function setupGridSizeToggle() {
  const buttons = document.querySelectorAll('.size-btn');
  if (!buttons.length) return;

  buttons.forEach(button => {
    button.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      buttons.forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');
      setState('selectedGridSize', parseInt(button.dataset.size));
    });
  });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#Calibrator">Calibrator</a></li><li><a href="global.html#DB_NAME">DB_NAME</a></li><li><a href="global.html#GRID_BUFFER">GRID_BUFFER</a></li><li><a href="global.html#TILES_PER_PAGE">TILES_PER_PAGE</a></li><li><a href="global.html#TILE_HEIGHT">TILE_HEIGHT</a></li><li><a href="global.html#TILE_WIDTH">TILE_WIDTH</a></li><li><a href="global.html#WHEEL_SCROLL_FACTOR">WHEEL_SCROLL_FACTOR</a></li><li><a href="global.html#WORLD_BOUNDS">WORLD_BOUNDS</a></li><li><a href="global.html#addTile">addTile</a></li><li><a href="global.html#addTileWithKey">addTileWithKey</a></li><li><a href="global.html#blobToDataURL">blobToDataURL</a></li><li><a href="global.html#clearAll">clearAll</a></li><li><a href="global.html#createCalibrator">createCalibrator</a></li><li><a href="global.html#createScene">createScene</a></li><li><a href="global.html#createTileStore">createTileStore</a></li><li><a href="global.html#deleteCustomTile">deleteCustomTile</a></li><li><a href="global.html#deletePlacement">deletePlacement</a></li><li><a href="global.html#deletePlacements">deletePlacements</a></li><li><a href="global.html#deleteTile">deleteTile</a></li><li><a href="global.html#diamondPoints">diamondPoints</a></li><li><a href="global.html#diamondPointsScaled">diamondPointsScaled</a></li><li><a href="global.html#drawWireGrid">drawWireGrid</a></li><li><a href="global.html#filterAndRenderPalette">filterAndRenderPalette</a></li><li><a href="global.html#filterPalette">filterPalette</a></li><li><a href="global.html#getPlacementBase">getPlacementBase</a></li><li><a href="global.html#getPlacements">getPlacements</a></li><li><a href="global.html#getState">getState</a></li><li><a href="global.html#getTiles">getTiles</a></li><li><a href="global.html#getVisibleBounds">getVisibleBounds</a></li><li><a href="global.html#gridOrigin">gridOrigin</a></li><li><a href="global.html#gridToScreen">gridToScreen</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#isWithinBounds">isWithinBounds</a></li><li><a href="global.html#loadImageElement">loadImageElement</a></li><li><a href="global.html#loadSavedPlacements">loadSavedPlacements</a></li><li><a href="global.html#preloadScene">preloadScene</a></li><li><a href="global.html#refreshSceneView">refreshSceneView</a></li><li><a href="global.html#renderPalette">renderPalette</a></li><li><a href="global.html#savePlacement">savePlacement</a></li><li><a href="global.html#savePlacements">savePlacements</a></li><li><a href="global.html#screenToGrid">screenToGrid</a></li><li><a href="global.html#screenToGridFloat">screenToGridFloat</a></li><li><a href="global.html#setActiveTile">setActiveTile</a></li><li><a href="global.html#setState">setState</a></li><li><a href="global.html#setupGridSizeToggle">setupGridSizeToggle</a></li><li><a href="global.html#setupPalette">setupPalette</a></li><li><a href="global.html#setupSearch">setupSearch</a></li><li><a href="global.html#startGame">startGame</a></li><li><a href="global.html#syncVisibleTiles">syncVisibleTiles</a></li><li><a href="global.html#updateDepths">updateDepths</a></li><li><a href="global.html#updatePaginationButtons">updatePaginationButtons</a></li><li><a href="global.html#updateScene">updateScene</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Fri Nov 21 2025 23:40:45 GMT+0900 (Korean Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
